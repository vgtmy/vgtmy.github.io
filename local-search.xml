<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>n8n:从入门到进阶.md</title>
    <link href="/2025/07/04/n8n-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6-md/"/>
    <url>/2025/07/04/n8n-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6-md/</url>
    
    <content type="html"><![CDATA[<p>n8n（发音为 “n-eight-n”）是一个强大的低代码自动化工具，它允许您连接各种具有 API 的应用程序，并通过可视化工作流实现数据自动化流转，<br>从而显著提升效率并降低重复性任务的成本。无论是简单的数据传输还是复杂的工作流，n8n 都能提供灵活的解决方案。</p><span id="more"></span><h2 id="🌍-一、n8n-版本选择"><a href="#🌍-一、n8n-版本选择" class="headerlink" title="🌍 一、n8n 版本选择"></a>🌍 一、n8n 版本选择</h2><p>在开始使用 n8n 之前，您需要选择适合您的运行方式：云版本或本地自托管版本。</p><ul><li><strong>n8n 云版本</strong>：由 n8n 官方提供托管服务。<ul><li><strong>优点</strong>：24&#x2F;7 全天候运行，无需自行维护服务器，设置简便。</li><li><strong>缺点</strong>：需要支付费用。</li></ul></li><li><strong>本地自托管版本</strong>：在您自己的服务器或本地计算机上运行 n8n。<ul><li><strong>优点</strong>：免费（社区版），拥有完全的控制权和灵活性，更注重隐私和安全，您可以完全掌控数据流和存储。对于遵守 GDPR 或 CCPA 等隐私法规至关重要。</li><li><strong>缺点</strong>：需要一定的技术基础和服务器维护经验。</li></ul></li></ul><p>本教程将重点介绍如何在本地机器上自托管 n8n，以便您免费体验其功能，这非常适合学习和实验。</p><h2 id="🚀-二、n8n-本地快速安装-使用-npm"><a href="#🚀-二、n8n-本地快速安装-使用-npm" class="headerlink" title="🚀 二、n8n 本地快速安装 (使用 npm)"></a>🚀 二、n8n 本地快速安装 (使用 npm)</h2><p>使用 npm (Node Package Manager) 是在本地运行 n8n 的推荐且最便捷的方式之一。</p><p><strong>步骤：</strong></p><ol><li><p><strong>⚙️ 前提条件：安装 Node.js</strong></p><ul><li><strong>要求</strong>：请确保您的机器上已安装 <strong>Node.js 18 或更高版本</strong>。</li><li><strong>下载 Node.js</strong>：<ul><li>访问 Node.js 官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></li><li>在官网首页，您通常会看到两个下载选项：LTS (Long Term Support长期支持版) 和 Current (最新版)。 <strong>推荐下载并安装 LTS 版本</strong>，因为它更稳定。</li><li>根据您的操作系统（Windows, macOS, Linux）下载对应的安装包。</li></ul></li><li><strong>安装 Node.js</strong>：<ul><li><strong>Windows</strong>: 双击下载的 <code>.msi</code> 安装包，按照安装向导的提示完成安装。 通常保持默认设置即可。 安装程序会自动将 Node.js 和 npm 添加到系统环境变量中。</li><li><strong>macOS</strong>: 双击下载的 <code>.pkg</code> 安装包，按照安装向导的提示完成安装。</li><li><strong>Linux</strong>: 您可以通过包管理器（如 <code>apt</code> for Debian&#x2F;Ubuntu, <code>yum</code> for Fedora）或从官网下载二进制文件进行安装。 例如，在 Debian&#x2F;Ubuntu 上，您可以参考 NodeSource 的指引来安装较新版本的 Node.js。</li></ul></li><li><strong>验证 Node.js 和 npm 安装</strong>：安装完成后，打开一个新的终端或命令提示符窗口，输入以下命令并按回车键：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr><tr><td><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-vnpm</span> -v<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>  如果分别显示了 Node.js 和 npm 的版本号（例如 <code>v18.x.x</code> 和 <code>9.x.x</code>），则表示安装成功。</p></li><li><p><strong>🖥️ 打开终端或命令提示符</strong></p><ul><li><strong>Windows</strong>:<ul><li>按 <code>Win</code> 键，输入 <code>cmd</code> 或 <code>PowerShell</code>，然后按回车。</li></ul></li><li><strong>macOS</strong>:<ul><li>打开“应用程序” &gt; “实用工具” &gt; “终端”。</li><li>或者使用 Spotlight 搜索 (Command + Space)，输入 <code>Terminal</code> 并按回车。</li></ul></li><li><strong>Linux</strong>:<ul><li>通常使用 <code>Ctrl + Alt + T</code> 快捷键。</li><li>或者在应用程序菜单中找到“终端”或“Terminal”。</li></ul></li></ul></li><li><p><strong>📦 全局安装 n8n</strong></p><ul><li>在打开的终端或命令提示符中，输入以下命令并按回车键：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr><tr><td><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> n8n -g<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>参数 <code>-g</code> 表示全局安装，这样 <code>n8n</code> 命令就可以在系统的任何路径下执行。</li><li>安装过程可能需要几分钟，具体时间取决于您的网络速度。</li><li><strong>权限问题（macOS&#x2F;Linux）</strong>：如果在 macOS 或 Linux 上遇到权限错误 (EACCES)，您可能需要在命令前加上 <code>sudo</code>：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr><tr><td><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> npm install n8n -g<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>  然后输入您的系统密码。 或者，更好的做法是配置 npm 以避免使用 <code>sudo</code>，但这超出了本快速入门的范围。</p></li><li><p><strong>⚡ 启动 n8n</strong></p><ul><li>安装完成后，在终端或命令提示符中输入以下任一命令并按回车键：</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr><tr><td><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">n8n<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>  或者 </p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr><tr><td><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">n8n <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><ul><li>您会看到终端输出一些启动信息，通常最后会提示 n8n 正在运行并在特定端口（默认为 5678）监听。</li></ul></li><li><p><strong>🌐 访问 n8n 用户界面</strong></p><ul><li>当终端显示 n8n 已成功启动后，打开您的网页浏览器（如 Chrome, Firefox, Edge 等）。</li><li>在地址栏输入：<code>http://localhost:5678</code> 并按回车。</li><li>此时，您应该能看到 n8n 的欢迎界面或管理员账户注册页面。</li></ul></li><li><p><strong>🔑 设置管理员账户 (Owner Account)</strong></p><ul><li>首次访问时，n8n 会引导您设置管理员账户。 请按照页面提示填写您的邮箱、设置密码。</li><li><strong>重要提示</strong>：请务必牢记此密码。 对于自托管的 n8n 社区版，默认不提供直接的“忘记密码”找回功能（需要通过命令行或修改配置文件等更复杂的方式重置，或依赖您配置的邮件服务）。</li><li>完成注册后，您将进入 n8n 的主仪表板界面。</li></ul></li><li><p><strong>🔧 （可选但建议）将 n8n 执行路径添加到环境变量 (如果未通过 npm 全局安装自动完成)</strong></p><ul><li><strong>说明</strong>：通常情况下，使用 <code>npm install n8n -g</code> 进行全局安装后，npm 会自动处理路径问题，使得您可以从任何终端窗口直接运行 <code>n8n</code> 命令。 但如果由于某些原因（例如 npm 配置问题或未使用 <code>-g</code> 安装后移动了文件），系统找不到 <code>n8n</code> 命令，您可能需要手动将其执行路径添加到系统的 <code>PATH</code> 环境变量中。</li><li><strong>如何查找 n8n 执行路径</strong>：如果 npm 全局安装成功，通常不需要这一步。 如果需要，可以使用 <code>npm root -g</code> 查看全局包的安装目录，n8n 的可执行文件通常在其 <code>bin</code> 子目录中，或者在 npm 的全局 <code>bin</code> 目录中。</li><li><strong>如何添加环境变量</strong>：<ul><li><strong>Windows</strong>: 搜索“环境变量” -&gt; “编辑系统环境变量” -&gt; “环境变量…”按钮 -&gt; 在“系统变量”或“用户变量”中找到 <code>Path</code> -&gt; 编辑 -&gt; 新建，然后添加包含 <code>n8n.cmd</code> (或类似可执行文件) 的目录路径。</li><li><strong>macOS&#x2F;Linux</strong>: 通常编辑 <code>~/.bash_profile</code>, <code>~/.zshrc</code> (取决于您的 shell) 文件，添加类似 <code>export PATH=&quot;$PATH:/path/to/n8n/bin&quot;</code> 的行 (将 <code>/path/to/n8n/bin</code> 替换为实际路径)，然后运行 <code>source ~/.bash_profile</code> 或 <code>source ~/.zshrc</code> 使其生效。</li></ul></li><li><strong>再次强调</strong>：对于大多数用户，通过 <code>npm install n8n -g</code> 正确安装后，这一步通常是<strong>不必要的</strong>。</li></ul></li></ol><h2 id="🖼️-三、用户界面概览"><a href="#🖼️-三、用户界面概览" class="headerlink" title="🖼️ 三、用户界面概览"></a>🖼️ 三、用户界面概览</h2><p>n8n 的主界面设计直观，主要包含以下几个部分：</p><ul><li><strong>左侧边栏</strong>：包含多个选项。<ul><li><strong>模板</strong>：提供了 n8n 官方和社区预构建的工作流模板，可以快速启动自动化之旅。</li><li><strong>变量</strong>：仅在企业版和云托管服务中可用。</li><li><strong>执行记录</strong>：显示您的工作流日志以及执行的成功与否。</li><li><strong>帮助</strong>：提供了 n8n 的官方文档和论坛链接。</li></ul></li><li><strong>主窗口</strong>：显示您创建的所有工作流。 您可以通过点击“从头开始”按钮或橙色的“添加工作流”按钮来添加新的工作流。</li><li><strong>设置</strong>：在屏幕底部点击三个点可以访问设置。 许多设置仅在企业版中提供，但您可以设置界面模式（亮色&#x2F;暗色）。 您也可以在工作流的设置中设置指定的时区，以确保计划触发的时间与您所在地一致。</li></ul><p>n8n 基于工作流程运行，这与 Zapier 的 Zaps 和 Make.com 的 Scenarios 类似。</p><h2 id="🛠️-四、入门：构建第一个工作流"><a href="#🛠️-四、入门：构建第一个工作流" class="headerlink" title="🛠️ 四、入门：构建第一个工作流"></a>🛠️ 四、入门：构建第一个工作流</h2><p>构建工作流是 n8n 的核心操作。</p><h3 id="🧠-1、核心概念："><a href="#🧠-1、核心概念：" class="headerlink" title="🧠 1、核心概念："></a>🧠 1、核心概念：</h3><ul><li><strong>工作流 (Workflow)</strong>：通常按照从左到右的顺序执行。</li><li><strong>节点 (Node)</strong>：工作流的基本组成单元，每个节点接收输入数据，进行处理，然后产生输出数据。</li><li><strong>数据流 (Data Flow)</strong>：数据在节点之间以 <strong>JSON 对象</strong> 的形式传递。</li><li><strong>数据迭代 (Data Iteration)</strong>：当数据以列表或数组形式存储时，n8n 会自动循环遍历或迭代数据，无需手动创建循环。</li></ul><h3 id="🧩-2、节点界面组成："><a href="#🧩-2、节点界面组成：" class="headerlink" title="🧩 2、节点界面组成："></a>🧩 2、节点界面组成：</h3><p>双击任何节点，会显示其详情视图：</p><ul><li><strong>Input (左侧)</strong>：显示节点接收到的输入数据。</li><li><strong>Node Details&#x2F;Parameters (中间)</strong>：节点的配置和参数设置。 这些设置根据节点类型而异。</li><li><strong>Output (右侧)</strong>：展示节点处理后输出的数据，这对于调试和优化至关重要。</li><li><strong>Docs</strong>：提供了该节点的文档链接。</li></ul><h3 id="✅-3、节点测试-Test-Step-："><a href="#✅-3、节点测试-Test-Step-：" class="headerlink" title="✅ 3、节点测试 (Test Step)："></a>✅ 3、节点测试 (Test Step)：</h3><ul><li>利用“Test Step”按钮，您可以单独执行当前节点并查看其输出结果，而无需执行整个工作流。 这对于调试和优化节点配置非常有用。</li><li>在输出视图中，您可以选择不同的数据视图（表格、JSON、架构）。 右上角的“固定”(Pin) 按钮非常实用，可以保持数据静态，避免每次测试时都进行查询。</li></ul><h3 id="💡-4、使用表达式访问数据："><a href="#💡-4、使用表达式访问数据：" class="headerlink" title="💡 4、使用表达式访问数据："></a>💡 4、使用表达式访问数据：</h3><ul><li>在节点配置中，可以使用花括号 <code>&#123;&#125;</code> 来访问来自先前节点的数据，这实际上是一个 <strong>JavaScript 表达式</strong>。</li><li>将需要插入变量的字段设置为“<strong>表达式 (Expression)</strong>”模式（通常会显示绿色文本），而不是“固定 (Fix)”模式。</li><li>您可以通过 JSON 表示法访问数据，例如 <code>&#123;&#123; $json.customerID &#125;&#125;</code>。</li><li>由于在花括号内使用 JavaScript，您还可以使用其他的 JavaScript 表达式，例如插入日期和时间、转换数据、验证数据等。 您只能在花括号中使用 JavaScript，不能使用 Python。 Code 节点支持 JavaScript 和 Python。</li></ul><h3 id="📝-5、步骤示例：构建一个简单的个性化消息工作流-基于源"><a href="#📝-5、步骤示例：构建一个简单的个性化消息工作流-基于源" class="headerlink" title="📝 5、步骤示例：构建一个简单的个性化消息工作流 (基于源)"></a>📝 5、步骤示例：构建一个简单的个性化消息工作流 (基于源)</h3><ol><li><strong>添加第一个节点 (数据获取)</strong>：使用一个节点获取客户数据列表（教程示例中使用的是 n8n 的演示节点，无需关心数据来源）。</li><li><strong>测试第一个节点</strong>：点击“Test Step”运行此节点，并在右侧查看其输出（例如，获取了五个客户的数据记录）。</li><li><strong>添加第二个节点 (数据提取和准备)</strong>：添加一个用于提取和准备数据的节点（例如 <code>Edit Fields</code> 节点）。<ul><li>双击节点查看其输入（来自前一个节点的客户数据）。</li><li>在节点设置中，删除默认字段，添加新的字段。</li><li><strong>提取字段</strong>：将前一个节点的输出数据中需要提取的字段（如 ID、姓名、描述）拖拽到新添加的字段中。</li><li>设置字段类型（例如，字符串）。</li><li>确认字段设置为“表达式”。</li></ul></li><li><strong>测试第二个节点</strong>：点击“Test Step”，可以看到它根据设置迭代处理了所有输入项目，提取了指定字段并创建了新的数据列表。</li><li><strong>添加第三个节点 (个性化消息)</strong>：点击加号按钮，添加一个用于发送个性化消息的节点（教程示例中使用“客户消息”节点）。<ul><li>双击节点，查看其输入（来自第二个节点的输出数据）。</li><li><strong>构建消息内容</strong>：在消息文本框中输入固定文本，并使用表达式插入变量。 例如，输入“您好”，然后将“客户姓名”字段拖入；输入“您的描述是”，然后将“客户描述”字段拖入。</li><li><strong>务必确认</strong>：拖入的字段设置为“表达式”模式，并显示绿色文本。</li></ul></li><li><strong>测试第三个节点</strong>：点击“Test Step”，可以看到它迭代处理了所有输入项目，并为每个客户创建了自定义消息。</li><li><strong>保存工作流</strong>：点击右上角的 [Save] 按钮保存您的工作流。</li><li><strong>工作流管理</strong>：您可以双击工作流名称进行重命名。 您还可以添加标签以便筛选和管理工作流。 在主页可以按标签筛选或按关键词搜索工作流。</li></ol><h2 id="🌟-五、进阶：探索更多功能"><a href="#🌟-五、进阶：探索更多功能" class="headerlink" title="🌟 五、进阶：探索更多功能"></a>🌟 五、进阶：探索更多功能</h2><p>掌握了基础知识后，您可以深入探索 n8n 的强大功能。</p><h3 id="📌-1、节点类型详解"><a href="#📌-1、节点类型详解" class="headerlink" title="📌 1、节点类型详解"></a>📌 1、节点类型详解</h3><p>n8n 提供了丰富多样的节点来构建复杂的工作流。</p><ul><li><strong>触发器节点 (Trigger Nodes)</strong>：定义工作流何时以及如何开始。<ul><li><strong>Manual Trigger</strong>：手动启动工作流，适用于开发和测试。</li><li><strong>Schedule Trigger</strong>：按计划时间触发工作流，可使用 Cron 表达式或时间间隔设置。</li><li><strong>On App Event</strong>：由其他第三方应用程序中的事件触发。</li><li><strong>On Webhook</strong>：接收到 HTTP 请求时触发工作流。</li><li><strong>On Form Submission</strong>：提交表单时触发。</li><li><strong>Execute Workflow</strong>：被其他工作流调用作为子工作流执行。</li><li><strong>Chat Message</strong>：在对话时触发工作流，常用于 AI Agent 和大型语言模型应用，如构建 RAG 系统。</li></ul></li><li><strong>应用节点 (App Nodes &#x2F; Action Nodes)</strong>：在不同的第三方应用中执行操作。 n8n 集成了多种常见应用，如 Gmail, Telegram, Shopify, MySQL, Pinecone, Supabase 等。 您可以通过搜索找到需要的应用节点。</li><li><strong>数据转换节点 (Data Transformation Nodes)</strong>：用于对数据进行操作和转换。<ul><li><strong>Code</strong>：允许您编写 JavaScript 或 Python 代码片段来处理数据。</li><li><strong>Edit Fields</strong>：添加、移除或修改 JSON 数据中的字段，是数据处理的重要节点。</li><li><strong>Merge</strong>：将来自不同节点的数据融合在一起。</li><li><strong>HTML</strong>：提取 HTML 中的信息。</li><li><strong>Limit</strong>：限制处理的数据项数量。</li></ul></li><li><strong>流程控制节点 (Flow Nodes)</strong>：控制工作流的执行流程。<ul><li><strong>Filter</strong>：根据条件过滤数据。</li><li><strong>IF</strong>：基于条件拆分工作流。</li><li><strong>Loop</strong>：循环处理数据项。</li><li><strong>Wait</strong>：等待上一个节点执行完成。</li><li><strong>Execute Workflow</strong>：执行另一个工作流。</li></ul></li></ul><h3 id="🤖-2、AI-自动化"><a href="#🤖-2、AI-自动化" class="headerlink" title="🤖 2、AI 自动化"></a>🤖 2、AI 自动化</h3><p>n8n 提供了强大的 AI 自动化能力，特别适用于构建自定义的 AI 应用程序。</p><ul><li><strong>n8n for AI</strong>：利用 n8n 的能力创建自定义 AI 应用。</li><li><strong>构建 AI Agent</strong>：通过连接特定的节点来构建 AI Agent。 核心节点包括：<ul><li><strong>Chat Model</strong>：连接各种大型语言模型 (LLM)，如 OpenAI, Gemini 等。</li><li><strong>Memory</strong>：为 AI Agent 添加长期记忆，使其在一定程度上超越上下文限制。</li><li><strong>Tools</strong>：允许 AI Agent 调用外部工具，例如向量数据库 Pinecone 或 Supabase 来构建 RAG 系统。</li></ul></li><li><strong>RAG (检索增强生成)</strong>：结合外部知识库（如数据库、文档）增强 AI Agent 生成响应的能力。 RAG 适用于智能客服、内容创作、知识管理、个性化推荐等场景。</li><li>n8n 也支持 LangChain 节点，便于将 AI 功能集成到工作流中。</li></ul><h3 id="🔗-3、集成与连接"><a href="#🔗-3、集成与连接" class="headerlink" title="🔗 3、集成与连接"></a>🔗 3、集成与连接</h3><p>n8n 通过多种方式连接外部服务和应用。</p><ul><li><strong>HTTP Request</strong>：允许您主动向外部 API 发送请求，获取数据。 例如，获取天气预报或股票价格。</li><li><strong>Webhook</strong>：n8n 可以创建一个 Webhook URL，被动接收外部服务推送的消息，从而触发工作流。 例如，接收支付平台的支付成功通知。 Webhooks 是 n8n 所有计划都支持的功能，而在 Zapier 中是高级功能。</li><li><strong>数据库连接</strong>：可以直接连接到 MySQL、Pinecone、Supabase 等数据库进行配置和操作。 这里的连接通常是指配置好连接信息，而不是让大模型生成 SQL。</li><li><strong>定制节点 (Custom Nodes)</strong>：如果 n8n 没有您需要的集成，您可以编写自己的定制节点来调用外部服务或转换数据。 n8n 的代码是开源的，您可以自由定制。</li><li><strong>MCP 服务端</strong>：n8n 也支持 MCP 服务器的配置和使用。</li></ul><h3 id="⚙️-4、复杂工作流逻辑与错误处理"><a href="#⚙️-4、复杂工作流逻辑与错误处理" class="headerlink" title="⚙️ 4、复杂工作流逻辑与错误处理"></a>⚙️ 4、复杂工作流逻辑与错误处理</h3><p>n8n 擅长处理复杂的逻辑。</p><ul><li><strong>分支与合并</strong>：可以使用 IF 或 Switch 节点进行条件分支。 Merge 节点用于合并来自不同分支的数据流。</li><li><strong>循环</strong>：Loop 节点用于循环处理数据列表。</li><li><strong>错误处理 (Error Handling)</strong>：n8n 提供了错误处理工作流，可以在主工作流失败时触发。 节点设置中的 <code>onError</code> 选项可以定义节点遇到错误时的行为，例如停止或忽略并继续。 <code>retryOnFail</code> 选项可以使节点在执行失败时重试直到成功。</li></ul><h3 id="👨‍💻-5、开发者工具"><a href="#👨‍💻-5、开发者工具" class="headerlink" title="👨‍💻 5、开发者工具"></a>👨‍💻 5、开发者工具</h3><p>n8n 提供了一些面向开发者的功能，使其比其他无代码工具更灵活。</p><ul><li><strong>Code 节点</strong>：直接在工作流中编写 JavaScript 或 Python 代码。</li><li><strong>输入&#x2F;输出视图</strong>：清晰展示节点的数据输入和输出，便于调试。</li><li><strong>数据固定 (Data Pinning)</strong>：固定节点的输出数据，在后续测试中重复使用，无需重新获取。</li><li><strong>环境 (Environments)</strong>：支持区分开发、测试、生产环境。</li><li><strong>版本控制</strong>：可以使用 Git 对工作流进行版本控制和备份。</li><li><strong>Sticky Notes</strong>：在工作流画布上添加注释。</li></ul><h2 id="🆚-六、n8n-vs-Zapier-Make"><a href="#🆚-六、n8n-vs-Zapier-Make" class="headerlink" title="🆚 六、n8n vs Zapier&#x2F;Make"></a>🆚 六、n8n vs Zapier&#x2F;Make</h2><p>了解 n8n 的定位有助于更好地选择工具。 n8n 和 Zapier&#x2F;Make 都旨在实现数据集成和工作流自动化，但适用于不同复杂度和定制需求的场景。</p><table><thead><tr><th>特性</th><th>n8n</th><th>Zapier</th><th>Make.com</th></tr></thead><tbody><tr><td><strong>上手难度</strong></td><td>相对较高</td><td>最简单</td><td>介于两者之间</td></tr><tr><td><strong>定价模式</strong></td><td>按工作流执行次数收费，不限制任务&#x2F;步骤数量；自托管免费&#x2F;便宜</td><td>按任务数量收费；每一步操作通常算作一个任务</td><td>相对 Zapier 更合理</td></tr><tr><td><strong>自托管</strong></td><td><strong>支持 (免费)</strong></td><td>不支持</td><td>不支持 (基于源信息推断，源 称其为闭源软件)</td></tr><tr><td><strong>灵活性</strong></td><td><strong>非常高</strong> (支持代码，可定制节点，灵活的逻辑控制)</td><td>相对较低 (代码受限，复杂逻辑构建困难)</td><td>相对较高 (支持复杂工作流)</td></tr><tr><td><strong>集成数量</strong></td><td>300+ (数量相对较少，但通过 HTTP 请求和定制节点弥补)</td><td>5,000+ (数量最多)</td><td>数量少于 Zapier，多于 n8n</td></tr><tr><td><strong>复杂逻辑</strong></td><td>支持分支、循环、合并、Code 节点等</td><td>复杂逻辑构建困难，Code 节点有严格限制</td><td>支持复杂工作流</td></tr><tr><td><strong>AI 自动化</strong></td><td>提供 LangChain 节点，可构建高级 AI Agent</td><td>提供 AI 驱动的 Zap 构建，AI 助手等</td><td>(源信息未详细提及 AI 自动化对比，但作为自动化平台通常也支持 AI 集成)</td></tr><tr><td><strong>开源&#x2F;闭源</strong></td><td><strong>开源</strong> (Source-available)</td><td>闭源</td><td>闭源</td></tr><tr><td><strong>社区</strong></td><td>活跃，40K+ 成员，提供社区论坛支持</td><td>提供社区支持，高级计划提供付费支持</td><td>(源信息未详细提及)</td></tr></tbody></table><p><strong>总结对比</strong>：</p><ul><li><strong>Zapier</strong>：集成数量最多，上手最容易，但价格最昂贵，灵活性最低，适合简单的线性自动化任务。</li><li><strong>n8n</strong>：灵活性最高，可进行无限定制，支持自托管，价格便宜（尤其是自托管），但集成数量最少，上手难度相对较高，适合技术团队构建复杂工作流。</li><li><strong>Make.com</strong>：介于 Zapier 和 n8n 之间，集成数量居中，支持构建复杂工作流，价格也更合理。</li></ul><p>许多技术人员青睐 n8n 的灵活性、自托管选项和强大的定制能力。</p><h2 id="📚-七、社区与资源"><a href="#📚-七、社区与资源" class="headerlink" title="📚 七、社区与资源"></a>📚 七、社区与资源</h2><p>n8n 拥有一个开放活跃的社区。</p><ul><li><strong>社区论坛</strong>：您可以在论坛上提问，通常能得到快速响应。</li><li><strong>官方文档</strong>：提供详细的节点和功能说明。</li><li><strong>工作流模板</strong>：官方和社区提供了大量的预构建模板，可以作为起点或学习参考。</li><li><strong>社区贡献</strong>：社区成员会分享自己的模板和心得。</li><li>您还可以找到许多关于 n8n 的教程和案例分享视频或文章。</li></ul><h2 id="🎉-八、总结"><a href="#🎉-八、总结" class="headerlink" title="🎉 八、总结"></a>🎉 八、总结</h2><p>n8n 是一个强大且灵活的自动化工具，特别适合需要高度定制和控制的工作流场景，尤其对于技术团队而言。 从简单的 npm 安装开始，您可以逐步掌握节点的使用、数据的处理和工作流的构建。 通过利用其表达式、AI 能力、丰富的节点和灵活的逻辑控制，您可以构建出各种复杂的自动化和智能化应用，让 AI 真正替代重复性工作。</p><p>希望这篇指南能为您提供扎实的 n8n 入门知识，并帮助您开启智能自动化之旅！ </p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>应用指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>n8n</tag>
      
      <tag>自动化</tag>
      
      <tag>工作流</tag>
      
      <tag>API</tag>
      
      <tag>入门</tag>
      
      <tag>进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker实战精通攻略</title>
    <link href="/2025/07/03/docker%E5%AE%9E%E6%88%98%E7%B2%BE%E9%80%9A%E6%94%BB%E7%95%A5/"/>
    <url>/2025/07/03/docker%E5%AE%9E%E6%88%98%E7%B2%BE%E9%80%9A%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p>本教程首先从基础入手，详细讲解了Docker的常用功能和命令，并结合实际案例，深入浅出地介绍了Docker网络模式的核心概念。这是理解和掌握Docker的必备技术基础，旨在帮助您快速掌握Docker实战技巧，提升工作效率。</p><span id="more"></span><h1 id="🐳-Docker实战精通攻略"><a href="#🐳-Docker实战精通攻略" class="headerlink" title="🐳 Docker实战精通攻略"></a>🐳 Docker实战精通攻略</h1><h2 id="🧠-一、Docker的核心概念"><a href="#🧠-一、Docker的核心概念" class="headerlink" title="🧠 一、Docker的核心概念"></a>🧠 一、Docker的核心概念</h2><p>Docker 是一个开源容器化平台，可以将应用和依赖打包成一个轻量、可移植的容器（Container）中运行，具有<strong>高效部署、资源隔离、跨平台移植</strong>等优点。</p><p>Docker 的几个核心组成部分：</p><ul><li><strong>镜像（Image）</strong>：类似于程序安装包，是容器运行的模板，通常来自 Docker Hub 等仓库。</li><li><strong>容器（Container）</strong>：镜像的运行实例，彼此之间彼此独立，可快速启动&#x2F;销毁。</li><li><strong>Docker 引擎（Docker Engine）</strong>：Docker 的运行环境和服务核心，负责构建和管理镜像及容器。</li><li><strong>Dockerfile</strong>：定义镜像构建步骤的脚本，支持从基础镜像构建自定义镜像。</li><li><strong>Docker Hub</strong>：官方镜像仓库，可托管公共或私有镜像。</li></ul><hr><h2 id="💻-二、Docker在多平台上的安装"><a href="#💻-二、Docker在多平台上的安装" class="headerlink" title="💻 二、Docker在多平台上的安装"></a>💻 二、Docker在多平台上的安装</h2><p>Docker 支持主流操作系统。以下是不同平台的安装方式概览：</p><h3 id="1-Windows"><a href="#1-Windows" class="headerlink" title="1. Windows"></a>1. Windows</h3><ul><li>安装 <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop for Windows</a></li><li>要求：Windows 10&#x2F;11 Pro 或启用 WSL2（Windows Subsystem for Linux）</li><li>启动 Docker Desktop 后会自动配置 Docker Engine</li></ul><h3 id="2-macOS"><a href="#2-macOS" class="headerlink" title="2. macOS"></a>2. macOS</h3><ul><li>安装 <a href="https://www.docker.com/products/docker-desktop/">Docker Desktop for Mac</a></li><li>支持 M1&#x2F;M2 芯片（基于 Apple Silicon 的版本）</li></ul><h3 id="3-Linux（以-Ubuntu-为例）"><a href="#3-Linux（以-Ubuntu-为例）" class="headerlink" title="3. Linux（以 Ubuntu 为例）"></a>3. Linux（以 Ubuntu 为例）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install     ca-certificates     curl     gnupg     lsb-release<br><br><span class="hljs-comment"># 添加 Docker GPG 密钥</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="hljs-built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-comment"># 添加 Docker 源</span><br><span class="hljs-built_in">echo</span>   <span class="hljs-string">&quot;deb [arch=<span class="hljs-subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg]   https://download.docker.com/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span>   | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br><span class="hljs-comment"># 安装 Docker 引擎</span><br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><p>安装后执行 <code>sudo docker run hello-world</code> 进行验证。</p><hr><h2 id="🧊-三、镜像下载与镜像站配置"><a href="#🧊-三、镜像下载与镜像站配置" class="headerlink" title="🧊 三、镜像下载与镜像站配置"></a>🧊 三、镜像下载与镜像站配置</h2><p>Docker 默认从 <a href="https://hub.docker.com/">Docker Hub</a> 拉取镜像，但访问速度可能较慢，可以配置国内镜像加速器。</p><h3 id="常用镜像站："><a href="#常用镜像站：" class="headerlink" title="常用镜像站："></a>常用镜像站：</h3><ul><li>阿里云加速器（需登录）：<code>https://&lt;你的ID&gt;.mirror.aliyuncs.com</code></li><li>网易：<code>http://hub-mirror.c.163.com</code></li><li>清华大学：<code>https://docker.mirrors.tuna.tsinghua.edu.cn</code></li></ul><h3 id="配置方法（Linux）："><a href="#配置方法（Linux）：" class="headerlink" title="配置方法（Linux）："></a>配置方法（Linux）：</h3><p>编辑 <code>/etc/docker/daemon.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://docker.mirrors.tuna.tsinghua.edu.cn&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后重启 Docker：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reexec<br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure><hr><h2 id="🔧-四、命令：创建与运行容器的关键"><a href="#🔧-四、命令：创建与运行容器的关键" class="headerlink" title="🔧 四、命令：创建与运行容器的关键"></a>🔧 四、命令：创建与运行容器的关键</h2><h3 id="常用命令总览"><a href="#常用命令总览" class="headerlink" title="常用命令总览"></a>常用命令总览</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>docker pull nginx</code></td><td>拉取镜像</td></tr><tr><td><code>docker images</code></td><td>查看本地镜像</td></tr><tr><td><code>docker run -d -p 8080:80 nginx</code></td><td>后台运行 nginx 容器</td></tr><tr><td><code>docker ps</code></td><td>查看运行中的容器</td></tr><tr><td><code>docker exec -it &lt;container_id&gt; /bin/bash</code></td><td>进入容器交互式终端</td></tr><tr><td><code>docker stop &lt;container_id&gt;</code></td><td>停止容器</td></tr><tr><td><code>docker rm &lt;container_id&gt;</code></td><td>删除容器</td></tr><tr><td><code>docker rmi &lt;image_id&gt;</code></td><td>删除镜像</td></tr></tbody></table><h3 id="示例：运行一个-Nginx-容器"><a href="#示例：运行一个-Nginx-容器" class="headerlink" title="示例：运行一个 Nginx 容器"></a>示例：运行一个 Nginx 容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name web -p 8080:80 nginx<br></code></pre></td></tr></table></figure><p>打开浏览器访问 <code>http://localhost:8080</code> 即可看到 Nginx 欢迎页。</p><hr><h2 id="🔍-五、容器内部调试技巧"><a href="#🔍-五、容器内部调试技巧" class="headerlink" title="🔍 五、容器内部调试技巧"></a>🔍 五、容器内部调试技巧</h2><p>容器是隔离环境，调试方式与主机不同。</p><h3 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it &lt;容器ID或名称&gt; /bin/bash<br></code></pre></td></tr></table></figure><p>或使用 <code>sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it &lt;容器ID&gt; sh<br></code></pre></td></tr></table></figure><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs &lt;容器ID&gt;<br></code></pre></td></tr></table></figure><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><ul><li>将主机文件拷贝到容器：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> ./index.html &lt;容器ID&gt;:/usr/share/nginx/html/index.html<br></code></pre></td></tr></table></figure><ul><li>从容器拷贝文件到主机：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> &lt;容器ID&gt;:/path/in/container ./local-dir<br></code></pre></td></tr></table></figure><hr><h2 id="🌐-六、Docker网络模式的深度解析"><a href="#🌐-六、Docker网络模式的深度解析" class="headerlink" title="🌐 六、Docker网络模式的深度解析"></a>🌐 六、Docker网络模式的深度解析</h2><p>Docker 支持多种网络模式，用于容器间通信：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td><code>bridge</code>（默认）</td><td>为容器创建专属桥接网络，容器间可通过 IP 或容器名通信</td></tr><tr><td><code>host</code></td><td>使用主机网络，性能好但不隔离端口</td></tr><tr><td><code>none</code></td><td>完全断网，需要手动配置网络</td></tr><tr><td>自定义网络</td><td>推荐使用，支持容器名 DNS 解析</td></tr></tbody></table><h3 id="创建自定义网络"><a href="#创建自定义网络" class="headerlink" title="创建自定义网络"></a>创建自定义网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create mynet<br>docker run -d --name app1 --network mynet nginx<br>docker run -it --name app2 --network mynet alpine ping app1<br></code></pre></td></tr></table></figure><p>容器 <code>app2</code> 可直接通过容器名 <code>app1</code> 访问另一个容器，避免使用 IP。</p><hr><h2 id="🧩-七、轻量级容器编排技术：Docker-Compose"><a href="#🧩-七、轻量级容器编排技术：Docker-Compose" class="headerlink" title="🧩 七、轻量级容器编排技术：Docker Compose"></a>🧩 七、轻量级容器编排技术：Docker Compose</h2><p>Docker Compose 是官方提供的容器编排工具，可以用 <code>docker-compose.yml</code> 文件描述多个服务。</p><h3 id="示例：运行-WordPress-MySQL"><a href="#示例：运行-WordPress-MySQL" class="headerlink" title="示例：运行 WordPress+MySQL"></a>示例：运行 WordPress+MySQL</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">mysql:5.7</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db_data:/var/lib/mysql</span><br><br>  <span class="hljs-attr">wordpress:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">wordpress</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:80&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">WORDPRESS_DB_HOST:</span> <span class="hljs-string">db</span><br>      <span class="hljs-attr">WORDPRESS_DB_PASSWORD:</span> <span class="hljs-string">example</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">db</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">db_data:</span><br></code></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p>访问 <code>http://localhost:8080</code> 即可。</p><hr><h2 id="🤖-八、AI辅助学习-Docker"><a href="#🤖-八、AI辅助学习-Docker" class="headerlink" title="🤖 八、AI辅助学习 Docker"></a>🤖 八、AI辅助学习 Docker</h2><p>AI 工具可以提升 Docker 学习效率，推荐以下几种方式：</p><h3 id="1-使用-ChatGPT-解答命令-配置问题"><a href="#1-使用-ChatGPT-解答命令-配置问题" class="headerlink" title="1. 使用 ChatGPT 解答命令&#x2F;配置问题"></a>1. 使用 ChatGPT 解答命令&#x2F;配置问题</h3><p>你可以问：</p><ul><li><code>如何使用 Docker Compose 绑定多个端口？</code></li><li><code>请帮我分析 Dockerfile 中的问题</code></li></ul><h3 id="2-AI辅助生成-Dockerfile-Compose-文件"><a href="#2-AI辅助生成-Dockerfile-Compose-文件" class="headerlink" title="2. AI辅助生成 Dockerfile &#x2F; Compose 文件"></a>2. AI辅助生成 Dockerfile &#x2F; Compose 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输入需求，让 AI 生成配置文件</span><br>我想运行一个基于 Node.js 的 Express 项目，并连接 MongoDB，帮我写 Dockerfile 和 docker-compose.yml<br></code></pre></td></tr></table></figure><h3 id="3-借助-AI-诊断容器问题"><a href="#3-借助-AI-诊断容器问题" class="headerlink" title="3. 借助 AI 诊断容器问题"></a>3. 借助 AI 诊断容器问题</h3><p>复制日志输出到 AI 工具中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs my-app<br></code></pre></td></tr></table></figure><p>粘贴输出到 AI，分析是否存在配置、权限或端口错误。</p><hr><h2 id="📘-总结"><a href="#📘-总结" class="headerlink" title="📘 总结"></a>📘 总结</h2><p>Docker 不只是一个工具，它代表了一种现代软件部署的思维方式。掌握它，需要理解：</p><ul><li>✅ 镜像和容器的基本运行机制  </li><li>✅ 如何在不同系统中配置环境  </li><li>✅ 多容器服务的协作与编排  </li><li>✅ 借助 AI 工具持续进步和优化</li></ul><p>持续练习，动手实验，你一定能成为 Docker 实战高手！</p><hr><blockquote><p>作者：vgtmy<br>更新时间：2025年7月<br>转载请注明出处 🌟</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>应用指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>实战</tag>
      
      <tag>教程</tag>
      
      <tag>AI</tag>
      
      <tag>镜像</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LibreELEC与Kodi指南</title>
    <link href="/2025/05/30/LibreELEC%E4%B8%8EKodi%E6%8C%87%E5%8D%97/"/>
    <url>/2025/05/30/LibreELEC%E4%B8%8EKodi%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<!-- 这里是模板内容 --><hr><p>LibreELEC 是一个开源的 Linux 发行版，内置 Kodi 媒体中心。它由已停止开发的 OpenELEC 项目发展而来，目标是提供一个轻量级、快速启动、资源占用极低的 Kodi 专用系统。LibreELEC 可直接开机进入 Kodi，支持多种芯片平台，包括 PC、树莓派、Amlogic、Rockchip 等，是运行 Kodi 的理想平台，尤其适用于性能较低的设备。</p><span id="more"></span><hr><h1 id="📥-LibreELEC-下载、安装与应用详细教程"><a href="#📥-LibreELEC-下载、安装与应用详细教程" class="headerlink" title="📥 LibreELEC 下载、安装与应用详细教程"></a>📥 LibreELEC 下载、安装与应用详细教程</h1><h2 id="🧩-一、LibreELEC-下载"><a href="#🧩-一、LibreELEC-下载" class="headerlink" title="🧩 一、LibreELEC 下载"></a>🧩 一、LibreELEC 下载</h2><p>要下载 LibreELEC，首先需根据设备平台选择正确版本。</p><h3 id="1-选择设备对应版本"><a href="#1-选择设备对应版本" class="headerlink" title="1. 选择设备对应版本"></a>1. 选择设备对应版本</h3><ul><li><p><strong>PC 平台</strong>  </p><ul><li>推荐：<code>Generic (AMD/Intel)</code>  </li><li>较老设备：<code>Generic Legacy (AMD/Intel/NVIDIA)</code></li></ul></li><li><p><strong>Amlogic 盒子</strong>  </p><ul><li>示例：S905 (GXBB)、S905X&#x2F;S905D (GXL)、S912 (GXM)</li></ul></li><li><p><strong>树莓派</strong>  </p><ul><li>专用版本，按型号区分：树莓派 0&#x2F;1、2&#x2F;3、4</li></ul></li></ul><h3 id="2-下载工具"><a href="#2-下载工具" class="headerlink" title="2. 下载工具"></a>2. 下载工具</h3><ul><li><strong>官方 LibreELEC USB&#x2F;SD 制作工具</strong>（适用于 PC 安装）</li><li><strong>Etcher</strong> 烧写工具（支持 Windows&#x2F;macOS&#x2F;Linux，适用于树莓派）</li></ul><h3 id="3-系统镜像版本参考"><a href="#3-系统镜像版本参考" class="headerlink" title="3. 系统镜像版本参考"></a>3. 系统镜像版本参考</h3><table><thead><tr><th>LibreELEC 版本</th><th>Kodi 版本</th><th>Linux 内核</th></tr></thead><tbody><tr><td>12.0.2</td><td>21.2</td><td>6.6.x</td></tr><tr><td>12.0 &#x2F; 12.0.1</td><td>21.0&#x2F;21.1</td><td>6.6.x</td></tr><tr><td>11.0</td><td>20.3</td><td></td></tr><tr><td>10.0</td><td>19.5</td><td></td></tr><tr><td>9.2</td><td>18.9</td><td></td></tr></tbody></table><hr><h2 id="💾-二、LibreELEC-安装"><a href="#💾-二、LibreELEC-安装" class="headerlink" title="💾 二、LibreELEC 安装"></a>💾 二、LibreELEC 安装</h2><h3 id="1-安装准备"><a href="#1-安装准备" class="headerlink" title="1. 安装准备"></a>1. 安装准备</h3><ul><li>一个 <strong>U 盘</strong>（用于 PC&#x2F;电视盒子）或 <strong>Micro SD 卡</strong>（用于树莓派）</li><li>安装目标设备（如 PC、盒子、树莓派）</li><li>一台下载镜像并烧录的电脑（Windows&#x2F;macOS&#x2F;Linux）</li><li>配件（树莓派）：HDMI、电源、网线&#x2F;无线模块</li></ul><h3 id="2-安装步骤"><a href="#2-安装步骤" class="headerlink" title="2. 安装步骤"></a>2. 安装步骤</h3><h4 id="方式一：使用-LibreELEC-制作工具（适用于-PC-电视盒子）"><a href="#方式一：使用-LibreELEC-制作工具（适用于-PC-电视盒子）" class="headerlink" title="方式一：使用 LibreELEC 制作工具（适用于 PC&#x2F;电视盒子）"></a><strong>方式一：使用 LibreELEC 制作工具（适用于 PC&#x2F;电视盒子）</strong></h4><ol><li>打开 LibreELEC 制作工具。</li><li>选择镜像文件，或根据提示下载适配版本。</li><li>插入 U 盘，选择目标设备（确认无误）。</li><li>点击“写入”，完成后拔出 U 盘。</li><li>将 U 盘插入目标设备，进入 BIOS 设置 USB 启动。</li><li>启动后按提示进行安装，安装完成后拔掉 U 盘。</li><li>重启后进入 LibreELEC。</li></ol><h4 id="方式二：使用-Etcher-烧写（适用于树莓派）"><a href="#方式二：使用-Etcher-烧写（适用于树莓派）" class="headerlink" title="方式二：使用 Etcher 烧写（适用于树莓派）"></a><strong>方式二：使用 Etcher 烧写（适用于树莓派）</strong></h4><ol><li>插入 Micro SD 卡，启动 Etcher。</li><li>选择镜像文件，选择 SD 卡为目标设备。</li><li>点击 <code>Flash!</code> 开始写入，完成后弹出卡。</li><li>插入树莓派，连接电源&#x2F;HDMI 等启动设备。</li><li>初次启动进入设置向导。</li></ol><hr><h2 id="🛠️-三、LibreELEC-首次设置"><a href="#🛠️-三、LibreELEC-首次设置" class="headerlink" title="🛠️ 三、LibreELEC 首次设置"></a>🛠️ 三、LibreELEC 首次设置</h2><p>LibreELEC 首次启动会进入图形化配置向导：</p><ol><li><strong>语言选择</strong>：选择简体中文等首选语言。</li><li><strong>主机名</strong>：修改默认名称（如 <code>LibreELEC</code>）。</li><li><strong>网络连接</strong>：<ul><li>有线：自动连接</li><li>无线：手动输入密码连接</li></ul></li><li><strong>服务配置</strong>：<ul><li><strong>SSH</strong>：高级用途，非必须时建议关闭。</li><li><strong>Samba (SMB)</strong>：用于局域网共享文件，建议开启。</li></ul></li><li>设置完成后可进入 Kodi 主界面。</li></ol><hr><h2 id="🎬-四、LibreELEC-Kodi-应用与设置"><a href="#🎬-四、LibreELEC-Kodi-应用与设置" class="headerlink" title="🎬 四、LibreELEC (Kodi) 应用与设置"></a>🎬 四、LibreELEC (Kodi) 应用与设置</h2><p>LibreELEC 的核心为 Kodi，配置 Kodi 才是系统的重点。</p><h3 id="常用设置技巧"><a href="#常用设置技巧" class="headerlink" title="常用设置技巧"></a>常用设置技巧</h3><ul><li><strong>电影集显示</strong>：<code>设置 → 媒体 → 视频</code> 开启“显示电影集”</li><li><strong>视频卡顿优化</strong>：Kodi 21 支持缓存设置，可调节缓冲区大小</li><li><strong>阿里云盘挂载</strong>：使用 WebDAV 或第三方插件作为视频源</li><li><strong>首选语言&#x2F;字幕&#x2F;音轨</strong>：<ul><li>设置默认语言为中文</li><li>默认开启中文字幕</li><li>默认音轨为国语</li></ul></li><li><strong>启动画面</strong>：可更换或关闭启动图（Kodi 开机画面）</li><li><strong>电影海报墙显示名称</strong>：修改 Kodi 界面设置</li><li><strong>插件推荐</strong>：<ul><li><code>PVR IPTV Simple Client</code>：电视直播</li><li><code>Zimuku</code>：字幕库插件</li><li><code>Emby / Jellyfin / Plex</code>：媒体服务器连接</li><li><code>The Movie Database</code>：视频信息刮削器</li></ul></li></ul><hr><h2 id="🧯-五、LibreELEC-故障排除"><a href="#🧯-五、LibreELEC-故障排除" class="headerlink" title="🧯 五、LibreELEC 故障排除"></a>🧯 五、LibreELEC 故障排除</h2><h3 id="1-无法从-U-盘启动（电视盒子）"><a href="#1-无法从-U-盘启动（电视盒子）" class="headerlink" title="1. 无法从 U 盘启动（电视盒子）"></a>1. 无法从 U 盘启动（电视盒子）</h3><ul><li>某些安卓盒子需刷入特殊固件或使用特定方式启动</li><li>建议查阅对应芯片型号的教程</li></ul><h3 id="2-Samba-网络共享不可用"><a href="#2-Samba-网络共享不可用" class="headerlink" title="2. Samba 网络共享不可用"></a>2. Samba 网络共享不可用</h3><ul><li>启用 LibreELEC 的 <code>Samba</code> 服务</li><li>检查 Windows 防火墙&#x2F;局域网设置</li></ul><h3 id="3-Kodi-刮削器无法连接-themoviedb"><a href="#3-Kodi-刮削器无法连接-themoviedb" class="headerlink" title="3. Kodi 刮削器无法连接 themoviedb"></a>3. Kodi 刮削器无法连接 themoviedb</h3><ul><li>可能与 <code>/storage/.kodi/addons</code> 目录下某些插件有关</li></ul><h3 id="4-HDMI-音频无法输出（树莓派）"><a href="#4-HDMI-音频无法输出（树莓派）" class="headerlink" title="4. HDMI 音频无法输出（树莓派）"></a>4. HDMI 音频无法输出（树莓派）</h3><ul><li>解决方法：<ul><li>在 <code>config.txt</code> 中添加 <code>hdmi_drive=2</code></li><li>确保电视在树莓派启动前已开机并设定 HDMI 输入</li><li>更换 HDMI 线缆，尝试不同的端口（HDMI0&#x2F;HDMI1）</li><li>树莓派 5：断电静置数分钟后重启，再检查音频输出</li></ul></li></ul><hr><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>希望本教程能帮助您顺利下载、安装并使用 LibreELEC。如果您在使用过程中遇到问题，欢迎查阅社区教程或继续探索更多 Kodi 插件扩展功能。</p>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
      <tag>LibreELCE</tag>
      
      <tag>Kodi</tag>
      
      <tag>指南</tag>
      
      <tag>家庭影院</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客部署到阿里云+GitHub自动部署全流程指南</title>
    <link href="/2025/05/26/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91-GitHub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%85%A8%E6%B5%81%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
    <url>/2025/05/26/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91-GitHub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%85%A8%E6%B5%81%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<!-- 这里是模板内容 --><p>将 Hexo 博客部署到阿里云服务器的完整流程如下，我们会从本地部署到服务器、配置域名、开放端口、防火墙、安全组等步骤一步一步来，适合初学者。</p><hr><span id="more"></span><h1 id="博客部署到阿里云"><a href="#博客部署到阿里云" class="headerlink" title="博客部署到阿里云"></a>博客部署到阿里云</h1><h2 id="🧱-一、前提准备"><a href="#🧱-一、前提准备" class="headerlink" title="🧱 一、前提准备"></a>🧱 一、前提准备</h2><p>你已经有这些资源：</p><ul><li>本地 Hexo 博客（可以正常 <code>hexo s</code> 预览）</li><li>一台阿里云服务器（IP 是 <code>47.111.124.118</code>）</li><li>一个域名 <code>vgtmy.com</code>（在阿里云买的）</li></ul><p>我们将做的事情是：</p><ol><li>把本地 Hexo 的静态文件传到服务器</li><li>用 Nginx 做网页服务器，部署 Hexo 到公网</li><li>配置阿里云服务器的防火墙和安全组</li><li>把域名 <code>vgtmy.com</code> 解析到你的服务器</li></ol><hr><h2 id="🧰-二、安装和准备环境"><a href="#🧰-二、安装和准备环境" class="headerlink" title="🧰 二、安装和准备环境"></a>🧰 二、安装和准备环境</h2><h3 id="1-本地打包博客"><a href="#1-本地打包博客" class="headerlink" title="1. 本地打包博客"></a>1. 本地打包博客</h3><p>在本地 Hexo 根目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br></code></pre></td></tr></table></figure><p>生成好的静态文件会在 <code>public/</code> 目录下。</p><hr><h3 id="2-连接你的阿里云服务器（使用-SSH）"><a href="#2-连接你的阿里云服务器（使用-SSH）" class="headerlink" title="2. 连接你的阿里云服务器（使用 SSH）"></a>2. 连接你的阿里云服务器（使用 SSH）</h3><p>在终端连接服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@47.111.124.118<br></code></pre></td></tr></table></figure><p>（第一次登录会提示是否确认，输入 <code>yes</code>）</p><hr><h3 id="3-安装-Nginx（在服务器上）"><a href="#3-安装-Nginx（在服务器上）" class="headerlink" title="3. 安装 Nginx（在服务器上）"></a>3. 安装 Nginx（在服务器上）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新系统</span><br>apt update &amp;&amp; apt upgrade -y     <span class="hljs-comment"># 如果是 Ubuntu 系统</span><br><span class="hljs-comment"># 安装 Nginx</span><br>apt install nginx -y<br></code></pre></td></tr></table></figure><hr><h2 id="🚚-三、部署-Hexo-到服务器"><a href="#🚚-三、部署-Hexo-到服务器" class="headerlink" title="🚚 三、部署 Hexo 到服务器"></a>🚚 三、部署 Hexo 到服务器</h2><h3 id="1-使用-scp-上传-public-文件夹到服务器"><a href="#1-使用-scp-上传-public-文件夹到服务器" class="headerlink" title="1. 使用 scp 上传 public/ 文件夹到服务器"></a>1. 使用 <code>scp</code> 上传 <code>public/</code> 文件夹到服务器</h3><p>在本地终端（Hexo 根目录下）运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r ./public/* root@47.111.124.118:/var/www/html/<br></code></pre></td></tr></table></figure><blockquote><p><code>/var/www/html/</code> 是 Nginx 默认的网站根目录。</p></blockquote><hr><h3 id="2-重启-Nginx"><a href="#2-重启-Nginx" class="headerlink" title="2. 重启 Nginx"></a>2. 重启 Nginx</h3><p>在服务器上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart nginx<br></code></pre></td></tr></table></figure><p>然后在浏览器访问：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//47.111.124.118</span><br></code></pre></td></tr></table></figure><p>你应该就能看到博客了！</p><hr><h2 id="🔐-四、设置阿里云防火墙与安全组"><a href="#🔐-四、设置阿里云防火墙与安全组" class="headerlink" title="🔐 四、设置阿里云防火墙与安全组"></a>🔐 四、设置阿里云防火墙与安全组</h2><p>登录阿里云控制台：</p><h3 id="1-打开服务器的-80-端口（HTTP）"><a href="#1-打开服务器的-80-端口（HTTP）" class="headerlink" title="1. 打开服务器的 80 端口（HTTP）"></a>1. 打开服务器的 80 端口（HTTP）</h3><ul><li><p>进入【云服务器 ECS】</p></li><li><p>找到你的实例，点击【安全组】</p></li><li><p>点击【配置规则】&gt;【添加安全组规则】</p><ul><li>协议类型：TCP</li><li>端口范围：80</li><li>授权对象：0.0.0.0&#x2F;0</li><li>备注：开放网页访问</li></ul></li></ul><p>保存即可。</p><hr><h2 id="🌐-五、配置域名解析（vgtmy-com）"><a href="#🌐-五、配置域名解析（vgtmy-com）" class="headerlink" title="🌐 五、配置域名解析（vgtmy.com）"></a>🌐 五、配置域名解析（vgtmy.com）</h2><p>登录阿里云【域名控制台】：</p><ol><li>找到你的域名 <code>vgtmy.com</code></li><li>进入【解析】页面，添加解析记录：</li></ol><table><thead><tr><th>类型</th><th>主机记录</th><th>记录值</th><th>线路</th></tr></thead><tbody><tr><td>A</td><td>@</td><td>47.111.124.118</td><td>默认线路</td></tr></tbody></table><p>如果你想让 <code>www.vgtmy.com</code> 也能访问：</p><table><thead><tr><th>类型</th><th>主机记录</th><th>记录值</th><th>线路</th></tr></thead><tbody><tr><td>A</td><td>www</td><td>47.111.124.118</td><td>默认线路</td></tr></tbody></table><hr><h2 id="🧪-六、访问网站"><a href="#🧪-六、访问网站" class="headerlink" title="🧪 六、访问网站"></a>🧪 六、访问网站</h2><p>解析通常需要几分钟到一小时不等。</p><p>你可以打开浏览器访问：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//vgtmy.com</span><br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.vgtmy.com</span><br></code></pre></td></tr></table></figure><p>就能看到你的博客上线了！</p><hr><h1 id="配置-HTTPS"><a href="#配置-HTTPS" class="headerlink" title="配置 HTTPS"></a>配置 HTTPS</h1><p>我们现在来为你的 Hexo 博客配置 <strong>HTTPS（SSL证书）</strong>，让访问 <code>https://vgtmy.com</code> 更安全、专业。</p><hr><h2 id="🛠️-一、申请免费-SSL-证书（阿里云）"><a href="#🛠️-一、申请免费-SSL-证书（阿里云）" class="headerlink" title="🛠️ 一、申请免费 SSL 证书（阿里云）"></a>🛠️ 一、申请免费 SSL 证书（阿里云）</h2><ol><li><p>打开阿里云控制台：<a href="https://yundun.console.aliyun.com/">https://yundun.console.aliyun.com</a></p></li><li><p>左侧进入 <strong>SSL证书管理</strong></p></li><li><p>点击【免费证书申请】</p></li><li><p>填写如下内容：</p><ul><li>证书品牌：<strong>阿里云</strong></li><li>域名类型：<strong>单域名</strong></li><li>域名：<code>vgtmy.com</code></li></ul></li><li><p>选择 DNS 验证或 文件验证（推荐 DNS）</p></li></ol><h4 id="✅-如果选择-DNS-验证："><a href="#✅-如果选择-DNS-验证：" class="headerlink" title="✅ 如果选择 DNS 验证："></a>✅ 如果选择 DNS 验证：</h4><ul><li>系统会提示你添加一条解析记录（如 <code>_dnsauth.vgtmy.com</code> → 某个字符串）</li><li>回到域名解析控制台，添加这条记录</li><li>验证成功后，证书会在十几分钟内签发完成</li></ul><hr><h2 id="💾-二、下载证书并上传到服务器"><a href="#💾-二、下载证书并上传到服务器" class="headerlink" title="💾 二、下载证书并上传到服务器"></a>💾 二、下载证书并上传到服务器</h2><p>签发完成后：</p><ol><li>在阿里云证书控制台中点击“下载”</li><li>选择服务器类型：<strong>Nginx</strong></li><li>下载压缩包（里面有两个文件，可能是 <code>.pem</code> 和 <code>.key</code>）</li></ol><h4 id="然后："><a href="#然后：" class="headerlink" title="然后："></a>然后：</h4><p>将证书上传到服务器，比如 <code>/etc/nginx/ssl/</code> 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /etc/nginx/ssl<br>scp yourdomain.pem root@47.111.124.118:/etc/nginx/ssl/<br>scp yourdomain.key root@47.111.124.118:/etc/nginx/ssl/<br></code></pre></td></tr></table></figure><hr><h2 id="⚙️-三、配置-Nginx-启用-HTTPS"><a href="#⚙️-三、配置-Nginx-启用-HTTPS" class="headerlink" title="⚙️ 三、配置 Nginx 启用 HTTPS"></a>⚙️ 三、配置 Nginx 启用 HTTPS</h2><p>编辑你的 Nginx 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /etc/nginx/sites-available/default<br></code></pre></td></tr></table></figure><p>把内容修改如下（或追加 SSL 配置）：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> vgtmy.com www.vgtmy.com;<br><br>    <span class="hljs-comment"># 自动跳转到 https</span><br>    <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span> vgtmy.com www.vgtmy.com;<br><br>    <span class="hljs-attribute">ssl_certificate</span> /etc/nginx/ssl/yourdomain.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span> /etc/nginx/ssl/yourdomain.key;<br><br>    <span class="hljs-attribute">root</span> /var/www/html;<br>    <span class="hljs-attribute">index</span> index.html;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ =<span class="hljs-number">404</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请根据你证书文件名替换 <code>yourdomain.pem</code> 和 <code>yourdomain.key</code>。</p><hr><h2 id="🔄-四、重启-Nginx-服务"><a href="#🔄-四、重启-Nginx-服务" class="headerlink" title="🔄 四、重启 Nginx 服务"></a>🔄 四、重启 Nginx 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t     <span class="hljs-comment"># 检查配置有没有错</span><br>systemctl reload nginx<br></code></pre></td></tr></table></figure><hr><h2 id="✅-五、访问测试"><a href="#✅-五、访问测试" class="headerlink" title="✅ 五、访问测试"></a>✅ 五、访问测试</h2><p>现在你可以访问：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//vgtmy.com</span><br></code></pre></td></tr></table></figure><p>如果看到小锁🔒图标，说明 HTTPS 配置成功啦！</p><h1 id="自动续签（Let’s-Encrypt）"><a href="#自动续签（Let’s-Encrypt）" class="headerlink" title="自动续签（Let’s Encrypt）"></a>自动续签（Let’s Encrypt）</h1><p>阿里云免费证书不能自动续期，90天过期。你也可以使用 Let’s Encrypt 来实现自动续期，我可以帮你搭配 certbot 安装。</p><hr><h2 id="✅-一、使用-Let’s-Encrypt-配置-HTTPS（自动续签）"><a href="#✅-一、使用-Let’s-Encrypt-配置-HTTPS（自动续签）" class="headerlink" title="✅ 一、使用 Let’s Encrypt 配置 HTTPS（自动续签）"></a>✅ 一、使用 Let’s Encrypt 配置 HTTPS（自动续签）</h2><p>我们将使用工具 <a href="https://certbot.eff.org/"><code>certbot</code></a> 自动申请证书并配置 Nginx。</p><h2 id="🛠️-步骤-1：安装-Certbot-工具"><a href="#🛠️-步骤-1：安装-Certbot-工具" class="headerlink" title="🛠️ 步骤 1：安装 Certbot 工具"></a>🛠️ 步骤 1：安装 Certbot 工具</h2><p>在你的阿里云服务器上运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt update<br>apt install certbot python3-certbot-nginx -y<br></code></pre></td></tr></table></figure><hr><h2 id="🌐-步骤-2：确保域名已经解析成功"><a href="#🌐-步骤-2：确保域名已经解析成功" class="headerlink" title="🌐 步骤 2：确保域名已经解析成功"></a>🌐 步骤 2：确保域名已经解析成功</h2><p>你已经把 <code>vgtmy.com</code> 和 <code>www.vgtmy.com</code> 指向了你的服务器 <code>47.111.124.118</code>，请确认它们已经能通过浏览器访问。</p><p>确认成功后继续。</p><hr><h2 id="🔐-步骤-3：使用-Certbot-自动申请证书并配置-Nginx"><a href="#🔐-步骤-3：使用-Certbot-自动申请证书并配置-Nginx" class="headerlink" title="🔐 步骤 3：使用 Certbot 自动申请证书并配置 Nginx"></a>🔐 步骤 3：使用 Certbot 自动申请证书并配置 Nginx</h2><p>在服务器上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">certbot --nginx<br></code></pre></td></tr></table></figure><p>然后它会一步步引导你：</p><ul><li>选择你要申请证书的域名（输入对应编号）</li><li>是否重定向 HTTP 到 HTTPS？选择 <strong>2（自动重定向）</strong></li></ul><p>如果你看到这类提示：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Congratulations! Your certificate <span class="hljs-keyword">and </span>chain have <span class="hljs-keyword">been </span>saved <span class="hljs-built_in">at</span>...<br></code></pre></td></tr></table></figure><p>说明证书申请成功并自动配置到了 Nginx。</p><hr><h2 id="🔄-步骤-4：自动续期任务确认"><a href="#🔄-步骤-4：自动续期任务确认" class="headerlink" title="🔄 步骤 4：自动续期任务确认"></a>🔄 步骤 4：自动续期任务确认</h2><p>Certbot 默认会自动添加续期任务（通过 <code>cron</code> 或 <code>systemd</code> 定时执行），你可以手动测试一次是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">certbot renew --dry-run<br></code></pre></td></tr></table></figure><p>输出没有报错就是 OK 的，证书将在每 60 天自动更新一次。</p><hr><h2 id="✅-最终效果验证"><a href="#✅-最终效果验证" class="headerlink" title="✅ 最终效果验证"></a>✅ 最终效果验证</h2><p>现在打开你的域名：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//vgtmy.com</span><br></code></pre></td></tr></table></figure><p>你应该可以看到：</p><ul><li>页面正常加载</li><li>地址栏出现 🔒 安全锁图标</li><li>支持 HTTPS，自动跳转 HTTP → HTTPS</li></ul><hr><h1 id="GitHub-Actions-自动部署"><a href="#GitHub-Actions-自动部署" class="headerlink" title="GitHub Actions 自动部署"></a>GitHub Actions 自动部署</h1><p>要实现 <strong>Hexo 博客通过 GitHub 自动部署（CI&#x2F;CD）到你的阿里云服务器</strong>，我们可以通过 GitHub Actions 实现一个完整的自动部署流程：</p><blockquote><p>🧠 目标效果是：你只要把博客内容推送到 GitHub，GitHub Actions 就自动构建并将生成的博客上传到你的阿里云服务器，自动上线！</p></blockquote><hr><h2 id="🧱-一、准备条件"><a href="#🧱-一、准备条件" class="headerlink" title="🧱 一、准备条件"></a>🧱 一、准备条件</h2><h3 id="✅-你需要有："><a href="#✅-你需要有：" class="headerlink" title="✅ 你需要有："></a>✅ 你需要有：</h3><ol><li>Hexo 博客项目已托管到 GitHub，例如 <code>https://github.com/yourname/hexo-blog</code></li><li>阿里云服务器的 SSH 登录信息（IP、用户名、密码或密钥）</li><li>确保服务器已部署好 Nginx 并指向 <code>/var/www/html</code></li></ol><hr><h2 id="🛠️-二、在-GitHub-上配置-SSH-密钥（推荐用密钥方式）"><a href="#🛠️-二、在-GitHub-上配置-SSH-密钥（推荐用密钥方式）" class="headerlink" title="🛠️ 二、在 GitHub 上配置 SSH 密钥（推荐用密钥方式）"></a>🛠️ 二、在 GitHub 上配置 SSH 密钥（推荐用密钥方式）</h2><h3 id="1-在你本地生成-SSH-密钥（如果还没有）"><a href="#1-在你本地生成-SSH-密钥（如果还没有）" class="headerlink" title="1. 在你本地生成 SSH 密钥（如果还没有）"></a>1. 在你本地生成 SSH 密钥（如果还没有）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;deploy@hexo&quot;</span><br></code></pre></td></tr></table></figure><p>一路回车，默认保存在 <code>~/.ssh/id_rsa</code> 和 <code>~/.ssh/id_rsa.pub</code></p><h3 id="2-把公钥复制到你的服务器"><a href="#2-把公钥复制到你的服务器" class="headerlink" title="2. 把公钥复制到你的服务器"></a>2. 把公钥复制到你的服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id -i ~/.ssh/id_rsa.pub root@47.111.124.118<br></code></pre></td></tr></table></figure><p>现在你应该可以免密登录服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh root@47.111.124.118<br></code></pre></td></tr></table></figure><hr><h3 id="3-把私钥添加到-GitHub-仓库的-Secrets"><a href="#3-把私钥添加到-GitHub-仓库的-Secrets" class="headerlink" title="3. 把私钥添加到 GitHub 仓库的 Secrets"></a>3. 把私钥添加到 GitHub 仓库的 Secrets</h3><ol><li>打开你的 GitHub 仓库页面</li><li>点击【Settings】&gt;【Secrets and variables】&gt;【Actions】</li><li>新增两个 Secrets：</li></ol><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td><code>SERVER_SSH_KEY</code></td><td>你本地生成的私钥内容（<code>~/.ssh/id_rsa</code> 的内容）</td></tr><tr><td><code>SERVER_HOST</code></td><td><code>47.111.124.118</code></td></tr><tr><td><code>SERVER_USERNAME</code></td><td><code>root</code>（或你设置的用户）</td></tr></tbody></table><hr><h2 id="📁-三、添加-GitHub-Actions-工作流配置"><a href="#📁-三、添加-GitHub-Actions-工作流配置" class="headerlink" title="📁 三、添加 GitHub Actions 工作流配置"></a>📁 三、添加 GitHub Actions 工作流配置</h2><p>在你的 Hexo 项目根目录新建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p .github/workflows<br>nano .github/workflows/deploy.yml<br></code></pre></td></tr></table></figure><p>填入以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">Aliyun</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span>   <span class="hljs-comment"># 根据你的默认分支调整，如是 master 就改成 master</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;18&#x27;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        npm install -g hexo-cli</span><br><span class="hljs-string">        npm install</span><br><span class="hljs-string"></span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">static</span> <span class="hljs-string">files</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">server</span> <span class="hljs-string">via</span> <span class="hljs-string">SSH</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">appleboy/scp-action@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SERVER_HOST</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SERVER_USERNAME</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SERVER_SSH_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;public/*&quot;</span><br>        <span class="hljs-attr">target:</span> <span class="hljs-string">&quot;/var/www/html/&quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="✅-四、测试部署流程"><a href="#✅-四、测试部署流程" class="headerlink" title="✅ 四、测试部署流程"></a>✅ 四、测试部署流程</h2><ol><li>将更改推送到 GitHub：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add GitHub Actions deploy&quot;</span><br>git push<br></code></pre></td></tr></table></figure><ol start="2"><li>打开 GitHub 仓库，进入【Actions】页面，查看 CI 是否成功执行</li><li>等待构建 + 部署成功后，访问你的博客：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//vgtmy.com</span><br></code></pre></td></tr></table></figure><p>博客应已自动更新！</p><hr><h2 id="🔁-五、未来如何部署？"><a href="#🔁-五、未来如何部署？" class="headerlink" title="🔁 五、未来如何部署？"></a>🔁 五、未来如何部署？</h2><p>你只需在本地写好文章、提交并推送到 GitHub：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment"># 编辑文章...</span><br>git add .<br>git commit -m <span class="hljs-string">&quot;update post&quot;</span><br>git push<br></code></pre></td></tr></table></figure><p><strong>博客就会自动构建并部署上线</strong>！</p><hr><h2 id="📦-六、可选优化（推荐）"><a href="#📦-六、可选优化（推荐）" class="headerlink" title="📦 六、可选优化（推荐）"></a>📦 六、可选优化（推荐）</h2><ul><li>支持多环境构建（如测试&#x2F;正式）</li><li>压缩图片、清理缓存等自动优化</li><li>添加构建状态徽章</li><li>配合 Cloudflare 的缓存刷新自动执行</li></ul><hr><h1 id="优化构建与部署流程"><a href="#优化构建与部署流程" class="headerlink" title="优化构建与部署流程"></a>优化构建与部署流程</h1><p>很好！我们接下来来进行 <strong>优化构建与部署流程</strong>，让你的 Hexo 博客部署更智能、高效。主要包括以下几个增强：</p><hr><h2 id="✅-一、自动压缩优化构建（图片压缩-清理）"><a href="#✅-一、自动压缩优化构建（图片压缩-清理）" class="headerlink" title="✅ 一、自动压缩优化构建（图片压缩 + 清理）"></a>✅ 一、自动压缩优化构建（图片压缩 + 清理）</h2><p>我们可以在 GitHub Actions 中加入构建优化步骤，让生成的静态文件更轻量、更快。</p><h3 id="1-安装优化插件（本地先装一次）"><a href="#1-安装优化插件（本地先装一次）" class="headerlink" title="1. 安装优化插件（本地先装一次）"></a>1. 安装优化插件（本地先装一次）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-neat --save<br></code></pre></td></tr></table></figure><p>然后在 Hexo 配置文件 <code>_config.yml</code> 中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">neat_html:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exclude:</span><br><span class="hljs-attr">neat_css:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">exclude:</span><br><span class="hljs-attr">neat_js:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">mangle:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">output:</span><br>    <span class="hljs-attr">beautify:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><blockquote><p>这样会自动压缩 HTML&#x2F;CSS&#x2F;JS，大幅减少页面体积。</p></blockquote><hr><h2 id="✅-二、自动刷新-Cloudflare-CDN-缓存（可选）"><a href="#✅-二、自动刷新-Cloudflare-CDN-缓存（可选）" class="headerlink" title="✅ 二、自动刷新 Cloudflare CDN 缓存（可选）"></a>✅ 二、自动刷新 Cloudflare CDN 缓存（可选）</h2><p>如果你启用了 Cloudflare CDN，加速效果会非常好。但部署更新后可能访问的还是缓存的旧页面，因此我们可以通过 GitHub Actions 自动刷新缓存！</p><h3 id="1-获取-Cloudflare-API-Token"><a href="#1-获取-Cloudflare-API-Token" class="headerlink" title="1. 获取 Cloudflare API Token"></a>1. 获取 Cloudflare API Token</h3><ul><li><p>登录 Cloudflare 控制台</p></li><li><p>进入个人设置 → API Tokens → 创建 Token</p></li><li><p>模板选择 <strong>“Purge Everything”</strong></p></li><li><p>设置权限：</p><ul><li>Zone.Zone:Read</li><li>Zone.Cache Purge:Edit</li></ul></li><li><p>限定你当前域名 <code>vgtmy.com</code></p></li></ul><p>生成后保存你的 API Token。</p><hr><h3 id="2-添加-Secrets-到-GitHub-仓库"><a href="#2-添加-Secrets-到-GitHub-仓库" class="headerlink" title="2. 添加 Secrets 到 GitHub 仓库"></a>2. 添加 Secrets 到 GitHub 仓库</h3><p>前往 GitHub 仓库设置：</p><table><thead><tr><th>Name</th><th>Value</th></tr></thead><tbody><tr><td><code>CF_ZONE_ID</code></td><td>你的 Cloudflare 区域 ID</td></tr><tr><td><code>CF_API_TOKEN</code></td><td>上面生成的 API Token</td></tr></tbody></table><p>你可以在 Cloudflare 控制台中找到 Zone ID（在域名首页信息栏里）</p><hr><h3 id="3-修改-deploy-yml-添加刷新-CDN-步骤"><a href="#3-修改-deploy-yml-添加刷新-CDN-步骤" class="headerlink" title="3. 修改 deploy.yml 添加刷新 CDN 步骤"></a>3. 修改 <code>deploy.yml</code> 添加刷新 CDN 步骤</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Purge</span> <span class="hljs-string">Cloudflare</span> <span class="hljs-string">Cache</span><br>  <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">    curl -X POST &quot;https://api.cloudflare.com/client/v4/zones/$&#123;&#123; secrets.CF_ZONE_ID &#125;&#125;/purge_cache&quot; \</span><br><span class="hljs-string">    -H &quot;Authorization: Bearer $&#123;&#123; secrets.CF_API_TOKEN &#125;&#125;&quot; \</span><br><span class="hljs-string">    -H &quot;Content-Type: application/json&quot; \</span><br><span class="hljs-string">    --data &#x27;&#123;&quot;purge_everything&quot;:true&#125;&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>添加在部署成功之后即可。</p></blockquote><hr><h2 id="✅-三、完整部署工作流模板（最终版）"><a href="#✅-三、完整部署工作流模板（最终版）" class="headerlink" title="✅ 三、完整部署工作流模板（最终版）"></a>✅ 三、完整部署工作流模板（最终版）</h2><p>这是一个<strong>完整 CI&#x2F;CD 工作流文件</strong>，具备构建优化、部署、刷新 Cloudflare 缓存的功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Deploy</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repo</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;18&#x27;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        npm install -g hexo-cli</span><br><span class="hljs-string">        npm install</span><br><span class="hljs-string"></span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Generate</span> <span class="hljs-string">optimized</span> <span class="hljs-string">static</span> <span class="hljs-string">files</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">server</span> <span class="hljs-string">via</span> <span class="hljs-string">SSH</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">appleboy/scp-action@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SERVER_HOST</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SERVER_USERNAME</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.SERVER_SSH_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">source:</span> <span class="hljs-string">&quot;public/*&quot;</span><br>        <span class="hljs-attr">target:</span> <span class="hljs-string">&quot;/var/www/html/&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Purge</span> <span class="hljs-string">Cloudflare</span> <span class="hljs-string">Cache</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        curl -X POST &quot;https://api.cloudflare.com/client/v4/zones/$&#123;&#123; secrets.CF_ZONE_ID &#125;&#125;/purge_cache&quot; \</span><br><span class="hljs-string">        -H &quot;Authorization: Bearer $&#123;&#123; secrets.CF_API_TOKEN &#125;&#125;&quot; \</span><br><span class="hljs-string">        -H &quot;Content-Type: application/json&quot; \</span><br><span class="hljs-string">        --data &#x27;&#123;&quot;purge_everything&quot;:true&#125;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h2 id="🔄-四、现在你拥有的是："><a href="#🔄-四、现在你拥有的是：" class="headerlink" title="🔄 四、现在你拥有的是："></a>🔄 四、现在你拥有的是：</h2><ul><li>💻 一套完整的 Hexo 博客源码在 GitHub 上管理</li><li>⚙️ 自动构建压缩优化后的静态页面</li><li>🚀 自动部署到阿里云服务器</li><li>☁️ 自动刷新 Cloudflare CDN 缓存</li><li>🔐 支持 HTTPS + 自动续签</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>学习心得</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>阿里云</tag>
      
      <tag>GitHub</tag>
      
      <tag>博客</tag>
      
      <tag>自动部署</tag>
      
      <tag>CI/CD</tag>
      
      <tag>Https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建Git代码仓库：代码版本控制与托管指南</title>
    <link href="/2025/05/25/%E6%90%AD%E5%BB%BAGit%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/"/>
    <url>/2025/05/25/%E6%90%AD%E5%BB%BAGit%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<!-- 这里是模板内容 --><h1 id="Git、Gitea-和-TortoiseGit：代码版本控制与托管指南"><a href="#Git、Gitea-和-TortoiseGit：代码版本控制与托管指南" class="headerlink" title="Git、Gitea 和 TortoiseGit：代码版本控制与托管指南"></a>Git、Gitea 和 TortoiseGit：代码版本控制与托管指南</h1><p>本文将介绍 Git 分布式版本控制系统，轻量级的自建 Git 服务 Gitea，以及 Git 的 Windows GUI 客户端 TortoiseGit。我们将探讨它们各自的功能、如何进行安装，以及如何将它们结合起来，为您的代码提供版本控制和集中托管。</p><h2 id="1-Git：分布式版本控制的核心"><a href="#1-Git：分布式版本控制的核心" class="headerlink" title="1. Git：分布式版本控制的核心"></a>1. Git：分布式版本控制的核心</h2><p><strong>Git</strong> 是一个开源的分布式版本控制软件，由 Linus Torvalds 设计开发，最初用于管理 Linux 内核开发。Git 的主要工作是创建和保存您项目的快照，并与之后的快照进行对比。它能够有效、高速地处理从很小到非常大的项目版本管理。</p><h3 id="Git-的工作区、暂存区和版本库"><a href="#Git-的工作区、暂存区和版本库" class="headerlink" title="Git 的工作区、暂存区和版本库"></a>Git 的工作区、暂存区和版本库</h3><p>理解 Git 的关键在于了解其三种文件状态及其交互方式:</p><ul><li><strong>工作目录 (Working Directory &#x2F; workspace)</strong>：这是您在本地计算机上看到的项目文件。您实际操作文件（查看、编辑、删除、创建）的地方就是工作目录。所有对文件的更改首先发生在这里。工作目录中的文件可能有<strong>未跟踪 (Untracked)</strong>（新创建，未被 Git 记录）或<strong>已修改 (Modified)</strong>（已被 Git 跟踪但更改未提交）状态。</li><li><strong>暂存区 (Staging Area &#x2F; 索引 Index)</strong>：这是一个临时存储区域，用于保存即将提交到本地仓库的更改。您可以选择性地将工作目录中的更改添加到暂存区，以便一次提交多个文件的更改。<code>git add &lt;filename&gt;</code> 命令用于将指定文件添加到暂存区，而 <code>git add .</code> 命令则用于将当前目录下的所有更改添加到暂存区。文件在暂存区时处于<strong>已暂存 (Staged)</strong> 状态。</li><li><strong>本地仓库 (Local Repository &#x2F; 版本库)</strong>：这是一个隐藏在 <code>.git</code> 目录中的数据库，用于存储项目的所有提交历史记录。每次提交更改时，Git 会将暂存区的内容保存到本地仓库中。<code>git commit -m &quot;commit message&quot;</code> 命令用于将暂存区中的更改提交到本地仓库。文件提交到本地仓库后，状态通常返回<strong>已跟踪 (Tracked)</strong>。</li><li><strong>远程仓库 (remote repository)</strong>：代码托管在远程服务器上的仓库副本。</li></ul><h3 id="Git-文件状态转换流程"><a href="#Git-文件状态转换流程" class="headerlink" title="Git 文件状态转换流程"></a>Git 文件状态转换流程</h3><p>文件状态的转换通常遵循以下流程：</p><ol><li><strong>未跟踪 (Untracked)</strong>：新创建的文件最初是未跟踪的，它们存在于工作目录中，但未被 Git 跟踪。使用 <code>touch newfile.txt</code> 创建文件后，<code>git status</code> 会显示其为未跟踪。</li><li><strong>已跟踪 (Tracked)</strong>：通过 <code>git add</code> 命令将未跟踪的文件添加到暂存区后，文件变为已跟踪状态。<code>git add newfile.txt</code> 命令可以将文件添加到暂存区，此时 <code>git status</code> 会显示该文件已暂存。</li><li><strong>已修改 (Modified)</strong>：对已跟踪的文件进行更改后，这些更改会显示为已修改状态，但这些更改还未添加到暂存区。例如，使用 <code>echo &quot;Hello, World!&quot; &gt; newfile.txt</code> 修改文件后，<code>git status</code> 会显示文件已修改。</li><li><strong>已暂存 (Staged)</strong>：使用 <code>git add</code> 命令将修改过的文件添加到暂存区后，文件进入已暂存状态，等待提交。</li><li><strong>已提交 (Committed)</strong>：使用 <code>git commit</code> 命令将暂存区的更改提交到本地仓库后，这些更改被记录下来，文件状态返回为已跟踪状态。例如，<code>git commit -m &quot;Added newfile.txt&quot;</code> 提交后，<code>git status</code> 会显示工作目录干净。</li></ol><h3 id="Git-基本操作命令"><a href="#Git-基本操作命令" class="headerlink" title="Git 基本操作命令"></a>Git 基本操作命令</h3><p>这里列出一些 Git 的常用命令:</p><ul><li><code>git init</code>: 初始化仓库。</li><li><code>git clone &lt;repository&gt;</code>: 拷贝一份远程仓库，也就是下载一个项目。克隆本地仓库时，命令格式为 <code>git clone &lt;source repository&gt; &lt;destination repository&gt;</code>，目标目录必须未创建或为空。</li><li><code>git status</code>: 查看仓库当前的状态，显示有变更的文件。<code>git status -s</code> 可获得简短状态输出。</li><li><code>git add &lt;file&gt;</code>: 添加文件到暂存区。</li><li><code>git add .</code>: 添加当前目录下所有更改过的文件至暂存区。</li><li><code>git commit -m &quot;message&quot;</code>: 提交暂存区到本地仓库。</li><li><code>git commit -am &quot;message&quot;</code>: 将 <code>add</code> 和 <code>commit</code> 合为一步，直接提交全部已跟踪文件的修改。注意，新建的未跟踪文件不会被提交。</li><li><code>git push</code>: 将本地库中的最新信息发送给远程库。例如 <code>git push origin master</code> 将当前分支推送到远程 <code>master</code> 分支。</li><li><code>git pull</code>: 从远程获取最新版本到本地，并自动合并。<code>git pull</code> 相当于 <code>git fetch</code> + <code>git merge</code>。</li><li><code>git fetch</code>: 从远程获取最新版本到本地，不会自动合并。</li><li><code>git merge</code>: 用于从指定的 commit 合并到当前分支。</li><li><code>git checkout</code>: 分支切换。也可用于从暂存区域复制文件到工作目录，丢弃本地修改 (<code>git checkout -- &lt;files&gt;</code>)。</li><li><code>git diff</code>: 比较工作区与暂存区的不同。还有多种用法，如比较暂存区与指定提交版本的不同 (<code>git diff --cached [&lt;commit&gt;]</code>)，工作区与指定提交版本的不同 (<code>git diff &lt;commit&gt;</code>)，或两个提交版本之间的不同 (<code>git diff &lt;commit&gt;..&lt;commit&gt;</code>)。</li><li><code>git log</code>: 查看历史提交记录。</li><li><code>git reset</code>: 回退版本。<code>git reset --hard HEAD</code> 将当前版本重置为 HEAD。也可用于撤销最后一次 <code>git add</code>。</li><li><code>git rm &lt;file&gt;</code>: 将文件从暂存区和工作区中删除。使用 <code>--cached</code> 只从暂存区中删除。</li><li><code>git mv &lt;source&gt; &lt;destination&gt;</code>: 移动或重命名工作区文件。</li></ul><p>要使用 Git，您需要在本地计算机上安装 Git 软件。具体的安装步骤未在源中详细说明，但通常需要从 Git 官方网站下载适用于您操作系统的安装程序。</p><h2 id="2-Gitea：您的轻量级自建-Git-服务器"><a href="#2-Gitea：您的轻量级自建-Git-服务器" class="headerlink" title="2. Gitea：您的轻量级自建 Git 服务器"></a>2. Gitea：您的轻量级自建 Git 服务器</h2><p><strong>Gitea</strong> 是一个轻量级的 DevOps 平台软件。它能够帮助团队和开发者高效轻松地处理软件生命周期中的工作，包括 Git 托管、代码审查、团队协作、软件包注册和 CI&#x2F;CD。Gitea 与 GitHub、Bitbucket 和 GitLab 等比较类似。</p><p>Gitea 的首要目标是创建一个<strong>极易安装、运行快速、安装和使用体验良好</strong>的自建 Git 服务。它采用 Go 作为后端语言，只需生成一个可执行程序即可，支持 Linux, macOS 和 Windows 等多平台及主流架构。</p><p>Gitea 的主要功能特性包括:</p><ul><li><strong>代码托管</strong>：支持创建和管理仓库、浏览历史、代码文件、审查和合并代码提交、管理协作者和分支等。</li><li><strong>轻量级和快速</strong>：设计目标之一是轻量级和快速响应，性能出色，适用于资源有限的环境。</li><li><strong>易于部署和维护</strong>：轻松部署在各种服务器上，不需要复杂的配置和依赖。</li><li><strong>安全性</strong>：提供用户权限管理、访问控制列表等功能。</li><li><strong>代码评审</strong>：支持 Pull Request workflow 和 AGit workflow，评审人可以在线浏览代码并提交意见。</li><li><strong>CI&#x2F;CD</strong>：Gitea Actions 支持 CI&#x2F;CD 功能，兼容 GitHub Actions。</li><li><strong>项目管理</strong>：通过看板和工单跟踪项目需求、功能和 bug。</li><li><strong>制品库</strong>：支持超过 20 种不同的软件包管理。</li><li><strong>开源社区支持</strong>：基于 MIT 许可证的开源项目，拥有活跃社区。</li><li><strong>多语言支持</strong>：提供多种语言界面。</li></ul><h3 id="使用-Docker-安装-Gitea"><a href="#使用-Docker-安装-Gitea" class="headerlink" title="使用 Docker 安装 Gitea"></a>使用 Docker 安装 Gitea</h3><p>通过 Docker 安装 Gitea 是一个推荐的方式。Gitea 在其 Docker Hub 组织内提供自动更新的 Docker 镜像。通常建议使用 <code>docker-compose</code> 进行设置。</p><p>以下是一个基于 <code>docker-compose.yml</code> 的基本设置示例，使用 SQLite3 数据库：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">gitea:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">docker.gitea.com/gitea:1.23.8</span> <span class="hljs-comment"># 推荐使用稳定版本标签</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">gitea</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">USER_UID=1000</span> <span class="hljs-comment"># 需要与 /data 卷所有者的 UID/GID 匹配（主机卷）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">USER_GID=1000</span> <span class="hljs-comment"># 对于命名卷则不需要担心权限问题</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">gitea</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./gitea:/data</span> <span class="hljs-comment"># 将主机当前目录下的 gitea 目录映射到容器的 /data</span><br>      <span class="hljs-comment"># 或使用命名卷: - gitea:/data (需在顶层定义 volumes: gitea: driver: local)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/timezone:/etc/timezone:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime:ro</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span> <span class="hljs-comment"># Web UI 端口映射</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;222:22&quot;</span>   <span class="hljs-comment"># SSH 端口映射</span><br></code></pre></td></tr></table></figure><p>您可以根据需要修改端口映射，只需更改主机端口即可。</p><p><strong>使用 MySQL 或 PostgreSQL 数据库</strong></p><p>您可以修改 <code>docker-compose.yml</code> 以使用外部数据库，例如 MySQL 或 PostgreSQL。这通常涉及添加一个数据库服务，并在 Gitea 服务中配置相应的环境变量 (<code>GITEA__database__DB_TYPE</code>, <code>GITEA__database__HOST</code>, <code>GITEA__database__NAME</code>, <code>GITEA__database__USER</code>, <code>GITEA__database__PASSWD</code>) 和 <code>depends_on</code>。</p><p><strong>启动与安装</strong></p><p>在包含 <code>docker-compose.yml</code> 文件的目录中执行 <code>docker-compose up -d</code> 即可在后台启动 Gitea。使用 <code>docker-compose ps</code> 查看状态，<code>docker-compose logs</code> 查看日志。要关闭，执行 <code>docker-compose down</code>。</p><p>启动后，通过浏览器访问 <code>http://server-ip:3000</code> (或您配置的其他端口) 完成安装向导。如果在 <code>docker-compose</code> 中启动了数据库服务，数据库主机名应填写 <code>db</code>。</p><p><strong>配置</strong></p><p>Gitea 的许多设置可以通过环境变量配置。环境变量的形式通常为 <code>GITEA__SECTION_NAME__KEY_NAME</code>。您也可以手动生成 <code>SECRET_KEY</code> 和 <code>INTERNAL_TOKEN</code> 并作为环境变量设置。配置文件 <code>app.ini</code> 安装后会保存在 <code>/data/gitea/conf/</code> 目录中。</p><p><strong>SSH 容器直通</strong></p><p>如果需要在容器内运行 SSH，可能需要设置 SSH 容器直通。这涉及在主机上创建一个与容器内 Gitea 用户 UID&#x2F;GID 相同的用户，挂载主机的 <code>.ssh</code> 目录到容器，创建主机 SSH 密钥对，并在主机上设置一个脚本将 SSH 请求转发到容器的 SSH 端口，同时修改主机的 <code>authorized_keys</code> 文件。将容器的 SSH 端口（22）映射到主机上的非标准端口（例如 2222）是一种方法，可以将端口映射到主机的 <code>localhost</code> (如 <code>127.0.0.1:2222:22</code>) 以便不对外暴露。</p><h3 id="创建-Gitea-操作用户"><a href="#创建-Gitea-操作用户" class="headerlink" title="创建 Gitea 操作用户"></a>创建 Gitea 操作用户</h3><p>如果需要将 Gitea 与 Jenkins 等工具对接以拉取代码，通常需要在 Gitea 中创建一个专门的用户。对于 http(s) 协议，需要用户名和密码；对于 ssh 协议，需要将本地 ssh 公钥提交到 Gitea 服务器。</p><p>创建用户的步骤（需要管理员权限）:</p><ol><li>进入 Gitea 管理后台 -&gt; 帐户管理页面 (<code>&lt;your gitea server&gt;/admin/users</code>)。</li><li>点击右上角“创建新帐户”按钮。</li><li>填写用户名（例如 <code>devops-bot</code>），认证源选择本地。</li><li>去掉“要求用户更改密码”的勾选，确保客户端可以使用设置的密码登录。</li><li>用户创建后，可能需要再次编辑将其设置为管理员或授予相应仓库的访问权限。</li></ol><p>为了让用户访问仓库，需要进行授权。一种方式是将用户添加到组织中的团队，并授予团队对仓库的权限（例如对所有仓库拥有管理权限）。</p><h2 id="3-TortoiseGit：Windows-上的-Git-GUI-客户端"><a href="#3-TortoiseGit：Windows-上的-Git-GUI-客户端" class="headerlink" title="3. TortoiseGit：Windows 上的 Git GUI 客户端"></a>3. TortoiseGit：Windows 上的 Git GUI 客户端</h2><p><strong>TortoiseGit</strong> 是一个 Git 的图形化界面客户端，特别是在 Windows 系统上。它可以帮助不熟悉命令行或偏好 GUI 操作的用户更方便地使用 Git 功能。</p><p>源中并未提供 TortoiseGit 的详细安装步骤，但通常需要从官方网站下载安装程序并进行安装。</p><h3 id="TortoiseGit-基本操作"><a href="#TortoiseGit-基本操作" class="headerlink" title="TortoiseGit 基本操作"></a>TortoiseGit 基本操作</h3><p>TortoiseGit 通过文件浏览器右键菜单提供 Git 操作。以下是使用 TortoiseGit 执行一些基本 Git 操作的示例:</p><ul><li><strong>建立仓库</strong>：可以通过 <code>git init</code> 方式 (在目录右键点击 <code>Git Create repository here</code>) 或 <code>git clone</code> 方式 (右键点击 <code>Git Clone</code>，填写远程仓库 URL 和本地目录) 来建立仓库。</li><li><strong>提交代码</strong>：在新文件或修改过的文件上右键，选择添加到暂存区 (add to cache)，然后再次右键选择提交到版本库 (commit)。填写提交信息并勾选文件后点击 commit。提交到本地版本库后，可以右键点击 push 推送到远程仓库。</li><li><strong>更新代码</strong>：右键点击 pull 从远程仓库更新代码。</li><li><strong>回滚版本</strong>：右键点击 <code>show log</code> 查看日志，选中某个版本右键点击 <code>Reset master to this</code> 进行版本回滚。</li><li><strong>显示日志</strong>：右键点击 <code>show log</code> 即可查看提交历史。</li><li><strong>创建分支</strong>：右键点击 <code>Create Branch</code> 创建新分支。创建后可以切换到新分支。</li><li><strong>解决冲突</strong>：当 push 或 pull 发生冲突时，文件会显示感叹号图标。右键点击 <code>Edit conflicts</code> 进入冲突编辑界面，手动合并代码后点击 <code>Mark as resolved</code>。</li><li><strong>忽略文件上传</strong>：创建 <code>.gitignore</code> 文件，并在其中定义不希望上传的文件（例如 <code>target.txt</code>）。</li><li><strong>设置比较工具</strong>：可以设置 Beyond Compare 等外部工具作为比较工具。</li></ul><h2 id="4-Git、Gitea-和-TortoiseGit-的相互应用"><a href="#4-Git、Gitea-和-TortoiseGit-的相互应用" class="headerlink" title="4. Git、Gitea 和 TortoiseGit 的相互应用"></a>4. Git、Gitea 和 TortoiseGit 的相互应用</h2><p>这三款工具结合使用可以构建一个完整的代码版本控制和托管环境：</p><ol><li><strong>Git 作为核心</strong>：Git 是底层的版本控制系统。所有的版本跟踪、提交、分支、合并等操作都是基于 Git 完成的。</li><li><strong>Gitea 作为远程仓库</strong>：Gitea 提供了一个中心化的平台来托管您的 Git 仓库。这使得团队协作、代码共享、代码审查和持续集成&#x2F;部署成为可能。您可以将本地 Git 仓库推送到 Gitea，也可以从 Gitea 克隆仓库到本地。</li><li><strong>TortoiseGit 作为客户端</strong>：TortoiseGit 提供了一个友好的图形界面，让您在 Windows 上更轻松地执行 Git 操作。您可以使用 TortoiseGit 来：<ul><li>从 Gitea 克隆一个仓库 (<code>Git Clone</code> 命令，填写 Gitea 仓库的 URL)。</li><li>在本地工作目录中修改文件。</li><li>使用右键菜单将更改的文件添加到暂存区 (<code>add</code>)。</li><li>使用右键菜单将暂存区的更改提交到本地仓库 (<code>commit</code>)。</li><li>使用右键菜单将本地仓库的提交推送到 Gitea 服务器 (<code>push</code>)。</li><li>使用右键菜单从 Gitea 服务器拉取最新代码到本地 (<code>pull</code>)。</li><li>通过 <code>show log</code> 查看本地或远程仓库的提交历史。</li><li>创建和切换分支以进行并行开发。</li><li>在进行 push 或 pull 时，如果出现冲突，使用 TortoiseGit 的工具解决冲突。</li></ul></li></ol><p>通过这种组合，Git 提供了强大的版本控制功能，Gitea 提供了集中的代码托管和协作平台，而 TortoiseGit 则通过易用的 GUI 简化了日常的 Git 操作。这使得个人或小型团队可以方便地搭建自己的代码管理系统。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Git、Gitea 和 TortoiseGit 各自扮演着不同的角色，但它们可以有效地结合起来，为您的项目提供 robust 的版本控制解决方案。Git 作为核心引擎，Gitea 提供远程托管和协作功能，而 TortoiseGit 则作为桌面客户端简化了 Windows 用户与 Git&#x2F;Gitea 的交互。通过理解它们的工作原理和基本操作，您可以更好地管理您的代码，提高开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>使用教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>github</tag>
      
      <tag>gitea</tag>
      
      <tag>TortoiseGit</tag>
      
      <tag>gitee</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenHands应用指南</title>
    <link href="/2025/05/25/OpenHands%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2025/05/25/OpenHands%E5%BA%94%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<!-- 这里是模板内容 --><p>欢迎使用 OpenHands（前身为 OpenDevin），这是一个由 AI 提供支持的软件开发代理平台。</p><p>OpenHands 代理可以做任何人类开发人员可以做的事情：修改代码、运行命令、浏览 Web、 调用 API，是的，甚至可以从 StackOverflow 复制代码片段。好的，这是一篇根据您提供的资料生成的 OpenHands 应用指南 Markdown 文档。</p><span id="more"></span><p>本文档将指导您如何开始使用 OpenHands，包括安装运行、连接语言模型（LLM）并配置 API 密钥，以及一些基本的使用方法和最佳实践。</p><h2 id="1-开始使用"><a href="#1-开始使用" class="headerlink" title="1. 开始使用"></a>1. 开始使用</h2><h3 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h3><p>运行 OpenHands 推荐的系统配置包括：</p><ul><li>支持 Docker Desktop 的 macOS</li><li>Linux</li><li>支持 WSL 和 Docker Desktop 的 Windows</li></ul><p>建议使用配备现代处理器和至少 <strong>4GB RAM</strong> 的系统。</p><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><p>确保您的系统已安装 Docker Desktop 并配置正确。</p><ul><li><strong>macOS</strong>: 安装 Docker Desktop 并确保在 <code>Settings &gt; Advanced</code> 中启用了 <code>Allow the default Docker socket to be used</code>。</li><li><strong>Linux</strong>: 安装 Docker Desktop。</li><li><strong>Windows</strong>: 安装 WSL (版本 2) 和 Docker Desktop。确保 Docker Desktop 的 WSL 2 基于引擎已启用，并且启用了与默认 WSL 发行版的集成。注意，Windows 用户需要在 WSL 终端中运行 Docker 命令来启动应用。</li></ul><h3 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h3><p>通过 Docker 运行 OpenHands 是最简单的方式。</p><p>首先拉取运行时镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull docker.all-hands.dev/all-hands-ai/runtime:0.39-nikolaik<br></code></pre></td></tr></table></figure><p>然后运行 OpenHands Docker 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> --pull=always \<br>-e SANDBOX_RUNTIME_CONTAINER_IMAGE=docker.all-hands.dev/all-hands-ai/runtime:0.39-nikolaik \<br>-e LOG_ALL_EVENTS=<span class="hljs-literal">true</span> \<br>-v /var/run/docker.sock:/var/run/docker.sock \<br>-v ~/.openhands-state:/.openhands-state \<br>-p 3000:3000 \<br>--add-host host.docker.internal:host-gateway \<br>--name openhands-app \<br>docker.all-hands.dev/all-hands-ai/openhands:0.39<br></code></pre></td></tr></table></figure><ul><li><code>--rm</code> 会在容器退出时自动移除容器 [未在源中，常见 Docker 用法]。</li><li><code>-v ~/.openhands-state:/.openhands-state</code> 将本地状态目录挂载到容器内，用于持久化设置。</li><li><code>-p 3000:3000</code> 将容器的 3000 端口映射到主机的 3000 端口，用于访问 UI。</li><li><code>--add-host host.docker.internal:host-gateway</code> 允许容器通过 <code>host.docker.internal</code> 访问主机网络，这在使用本地服务的 LLM 时很有用。</li></ul><p>启动后，您可以通过浏览器访问 <code>http://localhost:3000</code> 来使用 OpenHands。</p><blockquote><p><strong>警告</strong>: 如果您在公共网络上运行，请参考强化 Docker 安装指南，通过限制网络绑定和其他安全措施来保护您的部署。默认配置是为了本地开发方便而设计的。可以通过设置 <code>SANDBOX_RUNTIME_BINDING_ADDRESS=127.0.0.1</code> 和修改 <code>-p</code> 端口绑定来限制访问。</p></blockquote><p>您也可以将 OpenHands 连接到本地文件系统，运行脚本化的无头模式（Headless mode），通过交互式命令行界面（CLI Mode）进行交互，或通过 GitHub Action 在带标签的 issue 上运行。</p><h2 id="2-连接语言模型（LLM）与配置-API-密钥"><a href="#2-连接语言模型（LLM）与配置-API-密钥" class="headerlink" title="2. 连接语言模型（LLM）与配置 API 密钥"></a>2. 连接语言模型（LLM）与配置 API 密钥</h2><p>OpenHands 使用 LiteLLM 库连接并调用各种 LLM。为了正常工作，它需要一个强大的模型。</p><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>配置 LLM 模型和 API 密钥可以通过以下方式完成：</p><ol><li><p><strong>通过 UI 设置</strong>:</p><ul><li>首次启动时会看到设置弹窗，或者可以点击 UI 中的设置按钮（齿轮图标）进入设置页面。</li><li>在 <strong>LLM</strong> 标签页下：<ul><li>选择 <strong>LLM Provider</strong>（提供商）。</li><li>选择 <strong>LLM Model</strong>（模型）。</li><li>输入对应的 <strong>API Key</strong>。</li></ul></li><li>如果所需模型不在列表中，可以勾选 <strong>Advanced</strong>（高级）选项。</li><li>在高级设置中，使用 <strong>Custom Model</strong> 文本框手动输入模型名称，通常需要提供商前缀，例如 <code>openai/&lt;model-name&gt;</code> 或 <code>azure/&lt;deployment-name&gt;</code>。</li><li>如果提供商要求，还可以指定 <strong>Base URL</strong>（基本 URL）。</li></ul></li><li><p><strong>通过环境变量</strong>:</p><ul><li>在运行 OpenHands 的 Docker 命令时，可以使用 <code>-e</code> 参数设置环境变量来配置 LLM。</li><li>常用的环境变量包括：<ul><li><code>LLM_MODEL</code>：指定要使用的 LLM 模型。</li><li><code>LLM_API_KEY</code>：设置 API 密钥。</li><li><code>LLM_API_VERSION</code>：主要用于 Azure OpenAI，需要设置 API 版本。</li><li><code>LLM_BASE_URL</code>：设置 API 的基本 URL，用于 OpenAI 兼容端点、代理或本地模型。</li></ul></li></ul></li><li><p><strong>通过 <code>config.toml</code> 文件</strong>:</p><ul><li>在开发模式下运行 OpenHands 时，可以在 <code>config.toml</code> 文件中配置 LLM 设置。例如，在 <code>[llm]</code> 部分设置 <code>model</code> 和 <code>ollama_base_url</code>。</li></ul></li></ol><h3 id="支持的提供商和配置示例"><a href="#支持的提供商和配置示例" class="headerlink" title="支持的提供商和配置示例"></a>支持的提供商和配置示例</h3><p>OpenHands 通过 LiteLLM 支持连接到多种 LLM 提供商：</p><ul><li><strong>Azure OpenAI</strong>: 需要在 Docker 命令中设置 <code>LLM_API_VERSION</code> 环境变量。在 UI 中选择 <code>Azure</code> 提供商，设置 <code>&lt;deployment-name&gt;</code> 为 Custom Model（前缀 <code>azure/</code>），输入 Azure API Base URL 和 API Key。</li><li><strong>Google Gemini&#x2F;Vertex</strong>: Gemini 可在 UI 中选择 <code>Gemini</code> 提供商，选择或输入模型名称（前缀 <code>gemini/</code>），输入 API Key。Vertex AI 需要设置 <code>GOOGLE_APPLICATION_CREDENTIALS</code>, <code>VERTEXAI_PROJECT</code>, <code>VERTEXAI_LOCATION</code> 环境变量，并在 UI 中选择 <code>VertexAI</code> 提供商，选择或输入模型名称（前缀 <code>vertex_ai/</code>）。</li><li><strong>Groq</strong>: 可在 UI 中选择 <code>Groq</code> 提供商，选择或输入模型名称（前缀 <code>groq/</code>），输入 API Key。也可作为 OpenAI 兼容端点使用：在 UI 高级设置中，Custom Model 设置为 <code>openai/&lt;model-name&gt;</code>，Base URL 设置为 <code>https://api.groq.com/openai/v1</code>，并输入 Groq API Key。</li><li><strong>本地 LLMs</strong>: 通常需要先使用 LMStudio、SGLang 或 vLLM 等工具在本地服务模型。然后在 OpenHands UI 高级设置中配置 Custom Model (如 <code>lm_studio/&lt;model-name&gt;</code> 或 <code>openai/&lt;served-model-name&gt;</code>) 和 Base URL (如 <code>http://host.docker.internal:1234/v1</code> 或 <code>http://host.docker.internal:8000</code>)，并输入 API Key (如 <code>dummy</code> 或服务时设置的 key)。请注意，使用本地 LLM 可能功能受限，强烈推荐使用 GPU 服务模型以获得最佳体验。</li><li><strong>LiteLLM Proxy</strong>: 如果您设置了 LiteLLM Proxy 服务器，可以在 UI 高级设置中配置 Custom Model (前缀 <code>litellm_proxy/</code>)，Base URL 为您的 LiteLLM proxy URL，并输入 LiteLLM proxy API Key。支持的模型取决于您的代理配置。</li><li><strong>OpenAI</strong>: 在 UI 中选择 <code>OpenAI</code> 提供商，选择或输入模型名称（前缀 <code>openai/</code>），输入 API Key。也可使用 OpenAI 兼容端点或代理：在 UI 高级设置中，Custom Model 设置为 <code>openai/&lt;model-name&gt;</code>，Base URL 为代理 URL，输入 API Key。</li><li><strong>OpenRouter</strong>: 在 UI 中选择 <code>OpenRouter</code> 提供商，选择或输入模型名称（前缀 <code>openrouter/</code>），输入 API Key。</li></ul><h3 id="获取-API-密钥"><a href="#获取-API-密钥" class="headerlink" title="获取 API 密钥"></a>获取 API 密钥</h3><p>大多数语言模型都需要 API 密钥才能访问，并且通常会产生费用。建议从提供商的官方网站创建账户并生成 API 密钥。为了控制成本，建议设置使用限制并监控用量。例如，Anthropic 和 OpenAI 都提供了生成 API 密钥的流程。</p><h3 id="模型推荐"><a href="#模型推荐" class="headerlink" title="模型推荐"></a>模型推荐</h3><p>根据 SWE-bench 数据集的评估和社区反馈，以下是推荐且经验证可与 OpenHands 配合良好的模型：</p><ul><li><code>anthropic/claude-sonnet-4-20250514</code> (<strong>推荐</strong>)</li><li><code>openai/o4-mini</code></li><li><code>gemini/gemini-2.5-pro</code></li><li><code>deepseek/deepseek-chat</code></li><li><code>all-hands/openhands-lm-32b-v0.1</code> (通过 OpenRouter 可用)</li></ul><p>请注意，OpenHands 的能力很大程度上取决于所使用的 LLM 模型。当前大多数本地和开源模型可能不如这些推荐模型强大，可能导致响应慢、质量差或错误。</p><h3 id="API-重试和速率限制"><a href="#API-重试和速率限制" class="headerlink" title="API 重试和速率限制"></a>API 重试和速率限制</h3><p>LLM 提供商通常有速率限制，有时很低，可能需要重试。OpenHands 在收到速率限制错误 (429 错误码) 时会自动重试请求。您可以通过设置环境变量或在开发模式下的 <code>config.toml</code> 文件中自定义重试次数和等待时间。</p><h2 id="3-交互模式"><a href="#3-交互模式" class="headerlink" title="3. 交互模式"></a>3. 交互模式</h2><p>OpenHands 支持多种交互模式：</p><ul><li><strong>GUI Mode</strong>: 通过 web 界面 (<a href="http://localhost:3000/">http://localhost:3000</a>) 与 OpenHands 交互。这是最直观的方式，提供聊天面板、文件变化、内嵌 VS Code、终端、Jupyter 等功能视图。LLM 配置主要通过 UI 设置完成。</li><li><strong>CLI Mode</strong>: 提供一个交互式命令行界面，可直接在终端中与 OpenHands 交互。可以使用命令启动对话、查看状态、修改设置等。LLM 设置可以通过 <code>/settings</code> 命令或环境变量、<code>config.toml</code> 文件进行管理。</li><li><strong>Headless Mode</strong>: 允许您使用单个命令运行 OpenHands，无需启动 web 应用。这适用于编写脚本和自动化任务。配置通常通过环境变量或 <code>config.toml</code> 文件完成。</li></ul><h2 id="4-核心功能概览"><a href="#4-核心功能概览" class="headerlink" title="4. 核心功能概览"></a>4. 核心功能概览</h2><p>OpenHands GUI 提供了多个面板帮助您与 AI 代理协作：</p><ul><li><strong>Chat Panel</strong>: 显示用户与 OpenHands 之间的对话，OpenHands 会在此解释其行动。</li><li><strong>Changes</strong>: 显示 OpenHands 执行的文件更改。</li><li><strong>VS Code</strong>: 内嵌的 VS Code 编辑器，用于浏览、修改、上传和下载文件。</li><li><strong>Terminal</strong>: OpenHands 和用户都可以运行终端命令的空间。</li><li><strong>Jupyter</strong>: 显示 OpenHands 执行的所有 Python 命令，特别适合数据可视化任务。</li><li><strong>App</strong>: 显示 OpenHands 运行应用程序时的 web 服务器，用户可以与正在运行的应用交互。</li><li><strong>Browser</strong>: OpenHands 用来浏览网站的非交互式浏览器。</li></ul><h2 id="5-提示词最佳实践"><a href="#5-提示词最佳实践" class="headerlink" title="5. 提示词最佳实践"></a>5. 提示词最佳实践</h2><p>提供清晰有效的提示词是获得准确有用响应的关键。</p><ul><li><p><strong>好的提示词的特点</strong>:</p><ul><li><strong>具体 (Concrete)</strong>: 清晰描述要添加什么功能或修复什么错误。</li><li><strong>位置明确 (Location-specific)</strong>: 如果知道，请指定代码库中需要修改的位置。</li><li><strong>范围适当 (Appropriately scoped)</strong>: 专注于单个功能，通常不超过 100 行代码。</li></ul></li><li><p><strong>有效提示词的技巧</strong>:</p><ul><li>尽可能具体地说明期望的结果或要解决的问题。</li><li>提供上下文，包括相关文件路径和行号（如果可用）。</li><li>将大型任务分解为更小、更易管理的提示词。</li><li>包含相关的错误消息或日志。</li><li>如果不明朗，请指定编程语言或框架。</li></ul></li></ul><p>通过保持提示词的精确性和信息量，OpenHands 可以更好地协助您。</p><h2 id="6-仓库定制与微代理（Microagents）"><a href="#6-仓库定制与微代理（Microagents）" class="headerlink" title="6. 仓库定制与微代理（Microagents）"></a>6. 仓库定制与微代理（Microagents）</h2><p>您可以通过在仓库根目录创建 <code>.openhands</code> 目录来自定义 OpenHands 与您的仓库的交互方式。</p><h3 id="微代理（Microagents）"><a href="#微代理（Microagents）" class="headerlink" title="微代理（Microagents）"></a>微代理（Microagents）</h3><p>微代理是增强 OpenHands 领域特定知识的专用提示词，提供专家指导、自动化常见任务并确保项目实践的一致性。</p><ul><li><p><strong>微代理类型</strong>:</p><ul><li><strong>通用微代理 (General Microagents)</strong>: 为 OpenHands 提供关于仓库的一般性指导。这些微代理总是作为上下文的一部分加载。无需 frontmatter。放置在 <code>.openhands/microagents/repo.md</code>。</li><li><strong>关键字触发微代理 (Keyword-Triggered Microagents)</strong>: 当提示词中包含特定关键字时激活的指导。只有当提示词包含触发词时才会加载。需要 frontmatter 来定义触发词。放置在 <code>.openhands/microagents/&lt;name&gt;.md</code>。</li><li><strong>组织和用户微代理 (Organization and User Microagents)</strong>: 适用于组织或用户拥有的所有仓库的微代理。可以在组织或用户的 <code>.openhands</code> 仓库中创建 <code>microagents</code> 目录来放置这些微代理。</li></ul></li><li><p>要定制 OpenHands 的行为，在您的仓库根目录创建 <code>.openhands/microagents/</code> 目录，并在其中添加 <code>&lt;microagent_name&gt;.md</code> 文件。加载的微代理会占用上下文窗口空间，与用户消息一起为 OpenHands 提供任务和环境信息。</p></li></ul><h3 id="设置脚本与-Pre-commit-脚本"><a href="#设置脚本与-Pre-commit-脚本" class="headerlink" title="设置脚本与 Pre-commit 脚本"></a>设置脚本与 Pre-commit 脚本</h3><ul><li><strong>设置脚本 (<code>.openhands/setup.sh</code>)</strong>: 添加此文件，每次 OpenHands 开始处理您的仓库时都会运行。这是安装依赖、设置环境变量等设置任务的理想位置。</li><li><strong>Pre-commit 脚本 (<code>.openhands/pre-commit.sh</code>)</strong>: 添加此文件以创建自定义 git pre-commit hook，在每次提交前运行。可用于强制执行代码质量标准、运行测试等。</li></ul><h2 id="7-OpenHands-Cloud"><a href="#7-OpenHands-Cloud" class="headerlink" title="7. OpenHands Cloud"></a>7. OpenHands Cloud</h2><p>OpenHands Cloud 是 All Hands AI 提供的托管云版本。您可以通过 app.all-hands.dev 访问，需要使用 GitHub 或 GitLab 账户登录。</p><p>Cloud 版本提供以下功能：</p><ul><li><strong>Cloud UI</strong>: Web 界面，用于交互。</li><li><strong>Cloud API</strong>: REST API，允许程序化交互。可以通过 Cloud UI 的设置页面生成 API 密钥。</li><li><strong>Cloud Issue Resolver</strong>: 自动化代码修复和提供智能协助，尤其是在 GitHub 的 issues 和 pull requests 上。需要通过 GitHub&#x2F;GitLab 集成授予仓库访问权限。</li></ul><p>Cloud 版本是开始使用 OpenHands 的最简单方式，新用户提供免费额度。</p><h2 id="8-故障排除与社区"><a href="#8-故障排除与社区" class="headerlink" title="8. 故障排除与社区"></a>8. 故障排除与社区</h2><ul><li>如果您遇到问题，可以查阅故障排除指南。</li><li>常见的故障包括 API 密钥无法识别、组织访问被拒绝等，通常需要检查密钥是否正确、是否过期、权限是否正确，以及 SSO 是否启用等。</li><li>使用 CLI 模式时，如果遇到权限问题，请确保您的工作区目录受信任且环境变量设置正确。使用高级设置可以进行更深入的 LLM 配置。</li></ul><p>OpenHands 是一个社区驱动的项目。您可以通过以下渠道与社区互动：</p><ul><li>加入 Slack 工作区（讨论研究、架构和未来开发）。</li><li>加入 Discord 服务器（社区运营，用于一般讨论、问题和反馈）。</li><li>阅读或提交 GitHub Issues。</li></ul><p>要了解更多信息和高级配置选项，请查阅官方文档。</p><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>应用指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openhands</tag>
      
      <tag>OpenDevin</tag>
      
      <tag>Ai</tag>
      
      <tag>应用指南</tag>
      
      <tag>开发平台</tag>
      
      <tag>编程</tag>
      
      <tag>StackOverflow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo Fluid 主题：安装与设置指南</title>
    <link href="/2025/05/24/Hexo-Fluid-%E4%B8%BB%E9%A2%98%EF%BC%9A%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
    <url>/2025/05/24/Hexo-Fluid-%E4%B8%BB%E9%A2%98%EF%BC%9A%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-Fluid-主题：安装与设置指南"><a href="#Hexo-Fluid-主题：安装与设置指南" class="headerlink" title="Hexo Fluid 主题：安装与设置指南"></a>Hexo Fluid 主题：安装与设置指南</h2><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 Fluid-dev 开发与维护。本指南将基于您提供的资料，介绍如何安装和设置 Hexo Fluid 主题。</p><h2 id="开始使用：安装主题"><a href="#开始使用：安装主题" class="headerlink" title="开始使用：安装主题"></a>开始使用：安装主题</h2><p>在开始之前，您需要先搭建好 Hexo 博客。如果您还没有 Hexo 博客，请按照 Hexo 官方文档进行安装和建站。</p><p>安装 Fluid 主题有两种主要方式：</p><h3 id="方式一：通过-Npm-安装-推荐，Hexo-5-0-0-及以上版本"><a href="#方式一：通过-Npm-安装-推荐，Hexo-5-0-0-及以上版本" class="headerlink" title="方式一：通过 Npm 安装 (推荐，Hexo 5.0.0 及以上版本)"></a>方式一：通过 Npm 安装 (推荐，Hexo 5.0.0 及以上版本)</h3><p>进入您的 Hexo 博客目录，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code> 文件，并将主题目录下的 <code>_config.yml</code> 内容复制到新创建的 <code>_config.fluid.yml</code> 文件中。今后，所有主题配置的修改都建议在此文件中进行，以避免主题更新时丢失自定义配置。</p><h3 id="方式二：下载-Release-压缩包安装"><a href="#方式二：下载-Release-压缩包安装" class="headerlink" title="方式二：下载 Release 压缩包安装"></a>方式二：下载 Release 压缩包安装</h3><p>下载 Fluid 主题的最新 Release 版本。解压下载的压缩包到您 Hexo 博客目录下的 <code>themes</code> 文件夹。将解压出的文件夹重命名为 <code>fluid</code>。</p><p><strong>注意：</strong> 如果您选择此方式安装主题，建议学习使用 <strong>覆盖配置</strong> 功能，避免在更新主题时丢失自定义配置。对于 Hexo 5.0.0 版本及以上的用户，可以在博客目录下创建 <code>_config.fluid.yml</code> 文件；对于 Hexo 低于 5.0.0 但不低于 3.0.0 的用户，需要在博客目录下的 <code>source/_data</code> 目录（如不存在则创建）中创建 <code>fluid_config.yml</code> 文件。将主题的 <code>_config.yml</code> 内容复制到这些文件中进行修改。</p><h3 id="指定主题"><a href="#指定主题" class="headerlink" title="指定主题"></a>指定主题</h3><p>修改 Hexo 博客目录下的 <code>_config.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span> <span class="hljs-comment"># 指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><h3 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h3><p>首次使用主题时，需要手动创建「关于页」。在博客目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page about<br></code></pre></td></tr></table></figure><p>创建成功后，修改 <code>/source/about/index.md</code> 文件，添加 <code>layout: about</code> 属性。修改后的文件示例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 标题<br><span class="hljs-section">layout: about</span><br><span class="hljs-section">---</span><br>这里写关于页的正文，支持 Markdown , HTML<br></code></pre></td></tr></table></figure><p><strong>重要提示：</strong> <code>layout: about</code> <strong>必须存在，并且不能修改成其他值</strong>，否则不会显示头像等样式。</p><h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>主题配置可以通过修改 <code>theme/fluid/_config.yml</code> 或站点目录下的 <strong>主题配置文件</strong> (<code>_config.fluid.yml</code> 或 <code>source/_data/fluid_config.yml</code>) 来实现。推荐使用后者的覆盖配置方式。本指南提到的“站点配置”指 Hexo 博客目录下的 <code>_config.yml</code>，“主题配置”指 <code>theme/fluid/_config.yml</code> 或 <code>_config.fluid.yml</code>。</p><p>几乎每个配置在主题配置文件中都有注释，可配合指南共同参考使用。</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><ul><li><strong>覆盖配置</strong>: 如前所述，通过在站点根目录下创建 <code>_config.fluid.yml</code> (Hexo 5.0.0+) 或在 <code>source/_data/</code> 下创建 <code>fluid_config.yml</code> (Hexo &lt; 5.0.0)，可以将主题配置放在主题文件夹之外，以便于更新。<strong>只要存在于这些覆盖文件中的配置，优先级都高于主题自带的 <code>_config.yml</code></strong>。</li><li><strong>静态资源</strong>: 可以通过主题配置中的 <code>static_prefix</code> 修改静态资源文件的 URL。</li><li><strong>本地搜索</strong>: 已集成 <code>hexo-generator-search</code> 插件。默认生成并使用 <code>local-search.xml</code>。</li><li><strong>页面顶部大图 (Banner)</strong>: 主题配置中，每个页面都有 <code>banner_img</code> 属性。可以使用本地图片相对路径（相对于 <code>source</code> 目录，优先使用博客目录下的 <code>source</code>）或外站链接。建议图片大小在 1MB 以内。可以使用 <code>banner_img_height</code> (0-100) 控制高度，<code>banner_mask_alpha</code> (0-1.0) 控制蒙版透明度。<ul><li>每篇文章可以单独设置 Banner，详见文章页设置。</li><li>主题不支持固定背景 (fixed)。</li></ul></li><li><strong>博客标题</strong>: 页面左上角的标题默认使用 <strong>站点配置</strong> 中的 <code>title</code>。如需单独设置，可在 <strong>主题配置</strong> 中设置 <code>navbar.blog_title</code>。</li><li><strong>导航菜单</strong>: 在 <strong>主题配置</strong> 的 <code>navbar.menu</code> 中设置。每个菜单项包含 <code>key</code> (用于语言关联，或直接显示值)、<code>link</code> (跳转链接)、<code>icon</code> (图标 CSS Class，可省略) 和 <code>name</code> (强制显示名称，可省略)。支持二级菜单。</li><li><strong>懒加载</strong>: 默认开启。开启后，图片或评论插件在滚动到可见范围时才会加载，可提高网页打开速度。可在 <strong>主题配置</strong> 的 <code>lazyload</code> 项中设置是否启用 (<code>enable</code>)、加载占位图 (<code>loading_img</code>)、是否仅在文章页生效 (<code>onlypost</code>) 和触发加载的偏移倍数 (<code>offset_factor</code>)。</li><li><strong>全局字体</strong>: 可在 <strong>主题配置</strong> 的 <code>font</code> 项中设置全局字号 (<code>font_size</code>)、字体族 (<code>font_family</code>) 和代码字号 (<code>code_font_size</code>)。建议使用系统自带字体，并至少添加一个通用字体族名。</li><li><strong>网页统计</strong>: 支持多种统计服务，如百度统计、Google 统计、腾讯统计、51.la、友盟&#x2F;cnzz、LeanCloud。在 <strong>主题配置</strong> 的 <code>web_analytics</code> 项中开启并填入相应的 Key 或 ID。</li><li><strong>PV 与 UV 统计</strong>: 可在页脚展示。支持 LeanCloud 和 不蒜子。在 <strong>主题配置</strong> 的 <code>footer.statistics</code> 中设置是否启用 (<code>enable</code>)、数据源 (<code>source</code>) 和显示文本格式 (<code>pv_format</code>, <code>uv_format</code>)。<ul><li>不蒜子无需账号，但有时响应慢。LeanCloud 需要申请账号并填入 API 参数。</li></ul></li><li><strong>语言配置</strong>: 在 <strong>站点配置</strong> 的 <code>language</code> 项中设置。值需要对应主题 <code>languages/</code> 目录内的文件名。也可以通过在 <code>source/_data/languages</code> 目录下创建相应的 YAML 文件来自定义或新增语言配置。</li><li><strong>强制全局 HTTPS</strong>: 在 <strong>主题配置</strong> 中开启 <code>force_https: true</code> 可将所有请求强制升级为 HTTPS。</li><li><strong>二级站点路径</strong>: 如果博客部署在二级路径（如 <code>xxx.com/blog/</code>），需要修改 <strong>站点配置</strong> 中的 <code>url</code> 和 <code>root</code>。</li><li><strong>自定义 JS &#x2F; CSS &#x2F; HTML</strong>: 可在 <strong>主题配置</strong> 的 <code>custom_js</code>, <code>custom_css</code>, <code>custom_head</code>, <code>custom_html</code> 项中引入自定义代码或文件。<code>custom_js</code> 和 <code>custom_css</code> 支持指定多个路径。</li><li><strong>暗色模式</strong>: 在 <strong>主题配置</strong> 的 <code>dark_mode</code> 中开启 <code>enable: true</code>。<code>default</code> 参数可设置默认模式 (auto&#x2F;light&#x2F;dark)。</li><li><strong>OpenGraph</strong>: 默认开启。可在 <strong>主题配置</strong> 的 <code>open_graph</code> 项中完善相关信息。也可在文章 front-matter 中设置 <code>og_img</code> 指定单页面的 OpenGraph 图片。</li></ul><h3 id="首页设置"><a href="#首页设置" class="headerlink" title="首页设置"></a>首页设置</h3><ul><li><strong>Slogan (打字机)</strong>: 首页大图中的标题文字。可在 <strong>主题配置</strong> 的 <code>index.slogan</code> 中开启并设置文本。支持通过 API 获取内容。默认开启打字机动效，可在 <code>fun_features.typing</code> 中设置。</li><li><strong>文章摘要</strong>: 可在 <strong>主题配置</strong> 的 <code>index.auto_excerpt</code> 中开启&#x2F;关闭自动摘要 (默认开启)。手动指定摘要可通过在正文中使用 <code>&lt;!-- more --&gt;</code> 或在 front-matter 中设置 <code>excerpt</code> 字段。<strong>优先级：手动摘要 &gt; 自动摘要</strong>。</li><li><strong>文章跳转方式</strong>: 可在 <strong>主题配置</strong> 的 <code>index.post_url_target</code> 设置点击文章链接时的跳转方式 (<code>_blank</code> 新标签页, <code>_self</code> 当前标签页)。</li><li><strong>文章信息</strong>: 可在 <strong>主题配置</strong> 的 <code>index.post_meta</code> 控制首页文章列表中是否显示发布时间、分类、标签。</li><li><strong>隐藏文章</strong>: 在文章 front-matter 中设置 <code>hide: true</code> 可使文章不在首页及归档分类页中展示。隐藏后仍可通过链接访问。</li><li><strong>归档文章</strong>: 在文章 front-matter 中设置 <code>archive: true</code> 可使文章在首页隐藏，但仍在归档分类页中展示。</li><li><strong>文章排序 (置顶)</strong>: 如果安装了 <code>hexo-generator-index</code> &gt;&#x3D; 2.0.0 版本，可在文章 front-matter 中设置 <code>sticky</code> 属性。<code>sticky</code> 数值越大，文章越靠前。可通过 <strong>主题配置</strong> 的 <code>index.post_sticky</code> 控制是否显示置顶图标。</li></ul><h3 id="文章页设置"><a href="#文章页设置" class="headerlink" title="文章页设置"></a>文章页设置</h3><ul><li><strong>文章在首页的封面图</strong>: 在文章 front-matter 中设置 <code>index_img</code>。支持本地图片路径 (相对于 <code>source</code> 目录) 或外链。可在 <strong>主题配置</strong> 的 <code>post.default_index_img</code> 设置默认封面图。</li><li><strong>文章页顶部大图</strong>: 默认显示主题配置中的 <code>post.banner_img</code>。可在文章 front-matter 中指定 <code>banner_img</code> 设置单篇文章的顶部大图。</li><li><strong>文章内容图片</strong>: 本地图片存放位置（相对于 <code>source</code> 目录）同上。</li><li><strong>日期&#x2F;字数&#x2F;阅读时长&#x2F;阅读数</strong>: 显示在文章页大标题下方。可在 <strong>主题配置</strong> 的 <code>post.meta</code> 中开启&#x2F;关闭作者 (<code>author</code>)、日期 (<code>date</code>)、字数统计 (<code>wordcount</code>)、阅读时间 (<code>min2read</code>) 和阅读次数 (<code>views</code>)。阅读次数支持 LeanCloud 或 不蒜子。日期格式需遵循 ISO-8601 规范。</li><li><strong>代码块</strong>: 可在 <strong>主题配置</strong> 的 <code>code</code> 中设置是否开启复制按钮 (<code>copy_btn</code>)、行号 (<code>line_number</code>)、代码高亮 (<code>highlight</code>) 及选择高亮库 (<code>lib</code>，支持 highlightjs 和 prismjs)。</li><li><strong>评论</strong>: 在 <strong>主题配置</strong> 的 <code>post.comments</code> 中开启 <code>enable: true</code> 并指定 <code>type</code>。下方需设置对应评论模块的参数。主题支持多种评论插件，如 Valine, Waline, Gitalk, Disqus 等。可在文章或自定义页面 front-matter 中设置 <code>comment: bool</code> 或 <code>comment: &#39;type&#39;</code> 控制评论开关。</li><li><strong>脚注</strong>: 主题内置脚注语法支持。可在 <strong>主题配置</strong> 的 <code>post.footnote</code> 中开启 (<code>enable: true</code>)。支持在文末生成带锚点的脚注。</li><li><strong>Tag 插件</strong>: 主题内置多种 Tag 插件，如便签 (<code>&#123;% note %&#125;</code>), 行内标签 (<code>&#123;% label %&#125;</code>), 折叠块 (<code>&#123;% fold %&#125;</code>), 勾选框 (<code>&#123;% cb %&#125;</code>), 按钮 (<code>&#123;% btn %&#125;</code>) 和组图 (<code>&#123;% gi %&#125;</code>)。</li><li><strong>LaTeX 数学公式</strong>: 手动开启。需在 <strong>主题配置</strong> 的 <code>post.math</code> 中开启 (<code>enable: true</code>)，可设置是否按需加载 (<code>specific</code>) 和选择引擎 (<code>engine</code>，支持 mathjax 或 katex)。同时需要更换 Markdown 渲染器（如 hexo-renderer-pandoc + Pandoc for mathjax, 或 hexo-renderer-markdown-it + @traptitech&#x2F;markdown-it-katex for katex）。完成后需执行 <code>hexo clean</code>。</li><li><strong>Mermaid 流程图</strong>: 手动开启。需在 <strong>主题配置</strong> 的 <code>post.mermaid</code> 中开启 (<code>enable: true</code>)，可设置是否按需加载 (<code>specific</code>) 和配置选项 (<code>options</code>)。支持内置 Tag 或代码块书写。</li></ul><h3 id="其他页面"><a href="#其他页面" class="headerlink" title="其他页面"></a>其他页面</h3><ul><li><strong>归档页&#x2F;分类页&#x2F;标签页</strong>: 具体配置见主题配置文件注释。标签页支持词云展示。</li><li><strong>关于页</strong>: 前面已介绍创建方法。可在 <strong>主题配置</strong> 的 <code>about</code> 项中设置关于信息 (头像 <code>avatar</code>, 姓名 <code>name</code>, 简介 <code>intro</code>) 和社交图标 (<code>icons</code>)。社交图标可设置链接或二维码。</li><li><strong>友情链接页</strong>: 默认关闭。需先在 <code>navbar.menu</code> 中开启 <code>links</code> 菜单项，然后在 <code>links</code> 配置项中设置友情链接列表 (<code>items</code>)。支持自定义区域和评论。</li><li><strong>自定义页面</strong>: 可通过 <code>hexo new page example</code> 创建。可在 front-matter 或 <strong>主题配置</strong> 的 <code>page</code> 项中进行配置。自定义页面评论通过 front-matter 控制。如果需要与文章页功能相似的自定义页面，建议使用 <code>_posts</code> 并配合隐藏文章功能。</li><li><strong>404 页</strong>: 访问不存在的链接时显示。需要在部署环境上配置 (如 Nginx 的 <code>error_page 404</code>)。GitHub Pages 需绑定顶级域名才生效。主题包含默认 404 页面，也可在 <code>source</code> 目录下放置自定义的 <code>404.html</code>。</li></ul><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><p>根据您的安装方式，有不同的更新方法：</p><ul><li><strong>Npm 安装</strong>: 在博客目录下执行 <code>npm update --save hexo-theme-fluid</code>。</li><li><strong>Release 压缩包安装 (未修改代码)</strong>: 将原文件夹重命名备份，重新下载最新 Release 并解压重命名为 <code>fluid</code>。根据更新说明同步修改您的覆盖配置文件 (<code>_config.fluid.yml</code> 或 <code>source/_data/fluid_config.yml</code>)。</li><li><strong>自定义代码或体验其他分支</strong>: 确保 Fluid 目录开启 git 且所有改动已 commit。拉取对应分支的代码（如 dev 分支）：<code>git pull https://github.com/fluid-dev/hexo-theme-fluid.git develop</code>。解决代码冲突。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><strong>高级用法</strong>: 主题提供了 Fluid 代码注入功能，相比 Hexo 内置注入器，支持注入 ejs 代码，更细致丰富。可在博客目录 <code>scripts</code> 文件夹下创建 JS 文件，使用 <code>hexo.extend.filter.register(&#39;theme_inject&#39;, ...)</code> 来实现。</li><li><strong>Hexo 插件</strong>: 您提供的资料列出了一些推荐的 Hexo 插件，例如 <code>hexo-all-minifier</code> (压缩文件)、<code>hexo-abbrlink</code> (生成永久链接)、<code>live2d-widget</code> (看板娘) 等。<strong>请注意，所有插件仅作为推荐，不能保证完全与 Fluid 兼容，请仔细阅读插件文档</strong>。</li><li><strong>加快网页加载</strong>: 推荐使用 OSS (对象存储服务) 托管博客静态文件。对于本地图片，建议搭配 <code>hexo-all-minifier</code> 插件进行压缩；对于外部图片，建议使用 tinypng 等工具压缩。</li></ul><p><strong>提示</strong>: 每次无论是 <code>hexo g</code> (生成) 或 <code>hexo s</code> (本地服务)，都最好先使用 <code>hexo clean</code> 清除本地缓存，以避免奇怪的问题。</p><p>希望这篇指南能帮助您更好地安装和设置 Hexo Fluid 主题！</p><pre><code class="hljs"></code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>主题</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能个人应用：开启智能生活新时代</title>
    <link href="/2025/05/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%AA%E4%BA%BA%E5%BA%94%E7%94%A8/"/>
    <url>/2025/05/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%B8%AA%E4%BA%BA%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<!-- 这里是模板内容 --><p>在当今数字化飞速发展的时代，人工智能（AI）已不再是科幻电影中的概念，而是逐渐渗透到我们日常生活的方方面面，为普通人的生活带来了诸多便利和改变。从清晨被智能闹钟以最佳睡眠周期唤醒，到晚上通过语音助手关灯入睡，AI 技术正在以惊人的速度重塑我们的生活方式。以下将详细介绍人工智能在个人生活中的多种应用场景。</p><span id="more"></span><h2 id="智能个人助理：生活与工作的得力帮手"><a href="#智能个人助理：生活与工作的得力帮手" class="headerlink" title="智能个人助理：生活与工作的得力帮手"></a>智能个人助理：生活与工作的得力帮手</h2><p>智能个人助理是人工智能在个人应用中最为常见的形式之一。像苹果的 Siri、亚马逊的 Alexa、谷歌的 Google Assistant 以及国内的小爱同学等，它们已经成为人们日常生活中的重要助手。这些智能助理通过语音识别和自然语言处理技术，能够理解人类的自然语言，提供日常生活中的协助。</p><p>从设定闹钟、查询天气、播放音乐到发送短信等基础日常任务，用户只需简单地说出指令，智能助理就能迅速响应并完成。例如，当你在忙碌的工作中想要安排一个会议时，只需对智能助理说：“帮我安排明天下午三点的会议。”助手会自动为你检查日历并设置提醒，节省了大量时间。</p><p>除了基础功能，智能个人助理在设备控制、日程管理和信息检索方面也具有进阶功能。用户可以要求它们在智能家居系统中调整温度、控制灯光、管理家庭安全系统等。随着人工智能的不断进步，它们的理解能力和功能也在不断增强。此外，一些智能个人助理还具备学习用户习惯和偏好的能力，会根据用户的日常使用行为，调整自己的服务方式和提供的信息优先级，为用户提供更加个性化的服务。</p><p>在工作场景中，智能个人助理同样发挥着重要作用。它们可以协助用户管理日程安排，提醒重要的会议、任务截止日期等。对于需要处理大量文档和数据的工作，个人助手可以帮助用户快速检索和整理相关信息，提高工作效率。例如，在一个项目团队中，成员们可以通过与个人助手交互，快速获取项目文档中的关键信息，避免了在大量文件中手动查找的繁琐过程。</p><h2 id="个性化推荐系统：精准满足个人需求"><a href="#个性化推荐系统：精准满足个人需求" class="headerlink" title="个性化推荐系统：精准满足个人需求"></a>个性化推荐系统：精准满足个人需求</h2><p>个性化推荐系统几乎已经遍布于所有的数字产品和在线服务中，无论是在线购物、音乐、视频流媒体还是社交网络，人工智能都能分析用户的浏览和购买历史、评价反馈和搜索习惯，从而推送个性化的内容和产品。</p><p>在在线购物领域，电商平台如淘宝和京东利用 AI 技术分析用户的购物习惯，推荐合适的商品。这不仅提升了购物体验，也帮助用户找到更符合自己需求的产品。例如，当你在淘宝上浏览过某类商品后，平台会根据你的浏览记录和偏好，为你推荐相关的商品，让你在海量的商品中快速找到自己心仪的物品。</p><p>在音乐和视频流媒体平台，如 Spotify 和 Netflix，个性化推荐系统根据用户的收听和观看历史，为用户推荐可能喜欢的音乐和电影。这种个性化的体验使得用户能够更轻松地发现新内容，节省了用户在寻找感兴趣内容时的时间和精力。例如，当你在 Netflix 上观看了一部某类型的电影后，平台会为你推荐同类型或相关题材的其他电影，让你不断发现新的精彩。</p><h2 id="智能家居设备：打造舒适便捷的居住环境"><a href="#智能家居设备：打造舒适便捷的居住环境" class="headerlink" title="智能家居设备：打造舒适便捷的居住环境"></a>智能家居设备：打造舒适便捷的居住环境</h2><p>智能家居设备的快速发展已经改变了传统家居护理和管理方式。从智能照明、智能恒温器到安防系统、智能冰箱等，AI 技术让家居设备变得更加自动化和智能化。</p><p>用户可以通过智能手机应用程序、语音指令甚至是手势来控制这些设备，极大提升了生活质量和舒适度。例如，智能恒温器可以根据家庭成员的习惯和偏好自动调节家中的温度，当你在下班回家的路上，通过手机应用提前打开空调，一进家门就能享受到凉爽的空气。智能照明系统则能根据自然光线变化和人所在位置自动调节亮度和色温，为你营造一个舒适的居住环境。</p><p>智能家居的安防系统也得到了极大的提升。智能安防摄像头利用面部识别技术，能够识别家中的访客并实时推送警报通知给用户。门窗传感器可以监测门窗的开关状态，一旦发现异常情况，会及时向用户发出警报，保障家庭的安全。</p><p>健康监测应用是另一项受到广泛欢迎的 AI 应用。借助智能手表、健康追踪器和相关的移动应用程序，人们可以实时监控自己的健康状况，如心率、活动水平、睡眠质量和卡路里消耗等。这些设备不仅提供了个人健康数据，而且能通过 AI 分析给出健康建议和预警。</p><p>例如，智能手表可以实时监测用户的心率，当心率出现异常时，会及时提醒用户，并根据数据分析给出可能的原因和建议，如是否需要休息、就医等。一些先进的健康监测应用还可以通过分析语音、面部表情和打字模式来评估用户的心理状态，为用户提供更全面的健康关怀。</p><p>此外，AI 在医疗诊断领域也发挥着重要作用。一些 AI 系统能够处理和分析大量医疗数据，协助医生在影像诊断上识别疾病迹象。例如，AI 可以通过分析肺部 CT 图像，帮助医生更准确地诊断肺癌等疾病，提高了医疗诊断的效率和准确性。</p><p>汽车行业正在经历一场由 AI 驱动的革命，其中最为人们所瞩目的便是自动驾驶车辆。这些车辆能够通过集成的传感器、摄像头和先进的算法来感知周围环境，并做出驾驶决策。</p><p>虽然目前自动驾驶汽车还未完全成熟并普及，但是在特定环境下，如特斯拉 Autopilot 的部分自动驾驶功能已经被证明可以增加驾驶安全和便利性。自动驾驶车辆可以减少人为驾驶错误，降低交通事故的风险，同时还能优化路线选择，提高通勤效率。随着人工智能和机器学习技术的不断进步，未来的自动驾驶汽车有望实现完全无人驾驶，从而彻底改变人们的出行方式。</p><p>AI 在游戏和娱乐领域也扮演着越来越重要的角色。在视频游戏中，AI 被用来创建智能和逼真的非玩家角色（NPC）以及动态游戏环境。AI 驱动的 NPC 不仅让游戏世界更加生动逼真，还能根据玩家的行为动态调整策略，增加游戏的挑战性和趣味性。</p><p>例如，在大型角色扮演游戏中，NPC 不再是简单的对话机器，而是可以根据玩家的行为和选择做出多样化的反应，甚至能够与玩家建立起一定的情感联系。此外，AI 还被应用在电影特效制作、虚拟现实（VR）和增强现实（AR）技术中，为用户提供沉浸式的体验。通过 AI 技术，娱乐体验得到了前所未有的个性化和沉浸感。</p><p>AI 技术正在彻底改变传统教育模式。智能教育平台能够根据每个学生的学习能力、知识掌握程度和学习风格，定制完全个性化的学习路径和内容。语言学习 APP 利用 AI 语音识别和自然语言处理技术，提供实时发音纠正和对话练习；数学学习软件则能识别学生的思维过程，精准定位知识盲点。</p><p>更令人振奋的是，AI 虚拟教师可以 24 小时在线解答问题，打破了时间和空间的限制，使优质教育资源得以普惠。例如，一些在线教育平台利用 AI 技术，自动评估学生的学习进度，并根据他们的弱点推送相关的练习题或学习资源，帮助学生更好地掌握知识。</p><p>在交通与出行方面，AI 也发挥着重要作用。智能导航应用如谷歌地图、高德地图等，依赖 AI 优化路线，结合卫星图像与用户行为预测拥堵，甚至标记自行车道等细节，为用户提供更准确、更便捷的出行路线规划。此外，AI 支持的公共交通调度系统通过精确预测和实时调整，降低了拥堵，并提高了公共服务水平。</p><p>在金融与投资领域，AI 技术也得到了广泛应用。银行利用 AI 实现支票拍照存入、签名比对，反欺诈系统可实时监测异常交易，风险识别准确率远超人工。AI 算法能够预测股票市场的走势，为投资者提供投资建议。同时，一些智能理财工具可以根据用户的财务状况和目标，为用户制定个性化的理财计划，帮助用户实现财务目标。</p><p>对于博主和内容创作者来说，人工智能工具可以极大地提升创作效率。像 ChatGPT 这样的 AI 文本生成工具，可以帮助用户快速生成文章草稿、创意点子和社交媒体内容。通过与 AI 的互动，创作者可以获得灵感并优化他们的写作。此外，图像生成工具如 DALL - E 和 Canva 也能帮助用户快速制作图像和设计，减少了设计过程中的时间和成本。这些工具使得普通人能够以更低的门槛进行创作，表达自己的想法。</p><p>综上所述，人工智能已经深入到我们生活的各个方面，从智能个人助理到智能家居，从健康监测到游戏娱乐，AI 的应用无处不在。这些应用不仅提高了我们的生活质量，还极大地促进了社会的进步与发展。随着技术的不断进步和创新，相信人工智能在个人应用领域将会有更多的突破和发展，为我们带来更加智能、便捷、美好的生活。</p>]]></content>
    
    
    <categories>
      
      <category>科技、读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>人工智能</tag>
      
      <tag>个人应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智蕴年华，行摄人生</title>
    <link href="/2025/05/04/%E6%99%BA%E8%95%B4%E5%B9%B4%E5%8D%8E%EF%BC%8C%E8%A1%8C%E6%91%84%E4%BA%BA%E7%94%9F/"/>
    <url>/2025/05/04/%E6%99%BA%E8%95%B4%E5%B9%B4%E5%8D%8E%EF%BC%8C%E8%A1%8C%E6%91%84%E4%BA%BA%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<p>智蕴年华，猎奇不倦。行摄人生，笔耕不渝。</p><span id="more"></span><p>我，生于六零年代，就读于武汉，在一个江南小城市工作了30多年。工作生活都很平淡，过两年就要退休了。</p><p>为了让退休生活不至于枯燥无味，我现在开始学习写博客。年纪大了，学什么都难，这博客就当是我的学习笔记和心得。写得不好，请多赐教！</p><p>如果您也有类似的经历或兴趣，欢迎留言分享，我们一起交流学习！</p>]]></content>
    
    
    <categories>
      
      <category>自我介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>导航</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用命令使用大全</title>
    <link href="/2025/05/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/"/>
    <url>/2025/05/03/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="一、查看、添加、提交、删除、找回，重置修改文件"><a href="#一、查看、添加、提交、删除、找回，重置修改文件" class="headerlink" title="一、查看、添加、提交、删除、找回，重置修改文件"></a>一、查看、添加、提交、删除、找回，重置修改文件</h3><ul><li><code>git help &lt;command&gt;</code> # 显示 command 的 help</li><li><code>git show</code> # 显示某次提交的内容 <code>git show $id</code></li><li><code>git co -- &lt;file&gt;</code> # 抛弃工作区修改</li><li><code>git co .</code> # 抛弃工作区修改</li><li><code>git add &lt;file&gt;</code> # 将工作文件修改提交到本地暂存区</li><li><code>git add .</code> # 将所有修改过的工作文件提交暂存区</li><li><code>git rm &lt;file&gt;</code> # 从版本库中删除文件</li><li><code>git rm &lt;file&gt; --cached</code> # 从版本库中删除文件，但不删除文件</li><li><code>git reset &lt;file&gt;</code> # 从暂存区恢复到工作文件</li><li><code>git reset -- .</code> # 从暂存区恢复到工作文件</li><li><code>git reset --hard</code> # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</li><li><code>git ci &lt;file&gt;</code> <code>git ci .</code> <code>git ci -a</code> # 将 <code>git add</code>、<code>git rm</code> 和 <code>git ci</code> 等操作合并在一起</li><li><code>git ci -am &quot;some comments&quot;</code></li><li><code>git ci --amend</code> # 修改最后一次提交记录</li><li><code>git revert &lt;id&gt;</code> # 恢复某次提交的状态，恢复动作本身也创建次提交对象</li><li><code>git revert HEAD</code> # 恢复最后一次提交的状态</li></ul><h3 id="二、查看文件-diff"><a href="#二、查看文件-diff" class="headerlink" title="二、查看文件 diff"></a>二、查看文件 diff</h3><ul><li><code>git diff &lt;file&gt;</code> # 比较当前文件和暂存区文件差异</li><li><code>git diff &lt;id1&gt; &lt;id2&gt;</code> # 比较两次提交之间的差异</li><li><code>git diff &lt;branch1&gt;..&lt;branch2&gt;</code> # 在两个分支之间比较</li><li><code>git diff --staged</code> # 比较暂存区和版本库差异</li><li><code>git diff --cached</code> # 比较暂存区和版本库差异</li><li><code>git diff --stat</code> # 仅仅比较统计信息</li><li>查看提交记录<ul><li><code>git log</code></li><li><code>git log &lt;file&gt;</code> # 查看该文件每次提交记录</li><li><code>git log -p &lt;file&gt;</code> # 查看每次详细修改内容的 diff</li><li><code>git log -p -2</code> # 查看最近两次详细修改内容的 diff</li><li><code>git log --stat</code> # 查看提交统计信息</li></ul></li><li><code>tig</code> # Mac 上可以使用 <code>tig</code> 代替 <code>diff</code> 和 <code>log</code>，<code>brew install tig</code></li></ul><h3 id="三、Git-本地分支管理"><a href="#三、Git-本地分支管理" class="headerlink" title="三、Git 本地分支管理"></a>三、Git 本地分支管理</h3><h4 id="1-查看、切换、创建和删除分支"><a href="#1-查看、切换、创建和删除分支" class="headerlink" title="1. 查看、切换、创建和删除分支"></a>1. 查看、切换、创建和删除分支</h4><ul><li><code>git br -r</code> # 查看远程分支</li><li><code>git br &lt;new_branch&gt;</code> # 创建新的分支</li><li><code>git br -v</code> # 查看各个分支最后提交信息</li><li><code>git br --merged</code> # 查看已经被合并到当前分支的分支</li><li><code>git br --no-merged</code> # 查看尚未被合并到当前分支的分支</li><li><code>git co &lt;branch&gt;</code> # 切换到某个分支</li><li><code>git co -b &lt;new_branch&gt;</code> # 创建新的分支，并且切换过去</li><li><code>git co -b &lt;new_branch&gt; &lt;branch&gt;</code> # 基于 branch 创建新的 new_branch</li><li><code>git co $id</code> # 把某次历史提交记录 checkout 出来，但无分支信息，切换到其他分支会自动删除</li><li><code>git co $id -b &lt;new_branch&gt;</code> # 把某次历史提交记录 checkout 出来，创建成一个分支</li><li><code>git br -d &lt;branch&gt;</code> # 删除某个分支</li><li><code>git br -D &lt;branch&gt;</code> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</li></ul><h4 id="2-分支合并和-rebase"><a href="#2-分支合并和-rebase" class="headerlink" title="2. 分支合并和 rebase"></a>2. 分支合并和 rebase</h4><ul><li><code>git merge &lt;branch&gt;</code> # 将 branch 分支合并到当前分支</li><li><code>git merge origin/master --no-ff</code> # 不要 Fast-Foward 合并，这样可以生成 merge 提交</li><li><code>git rebase master &lt;branch&gt;</code> # 将 master rebase 到 branch，相当于：<code>git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</code></li></ul><h3 id="四、Git-补丁管理-方便在多台机器上开发同步时用"><a href="#四、Git-补丁管理-方便在多台机器上开发同步时用" class="headerlink" title="四、Git 补丁管理 (方便在多台机器上开发同步时用)"></a>四、Git 补丁管理 (方便在多台机器上开发同步时用)</h3><ul><li><code>git diff &gt; ../sync.patch</code> # 生成补丁</li><li><code>git apply ../sync.patch</code> # 打补丁</li><li><code>git apply --check ../sync.patch</code> # 测试补丁能否成功</li></ul><h3 id="五、Git-暂存管理"><a href="#五、Git-暂存管理" class="headerlink" title="五、Git 暂存管理"></a>五、Git 暂存管理</h3><ul><li><code>git stash</code> # 暂存</li><li><code>git stash list</code> # 列所有 stash</li><li><code>git stash apply</code> # 恢复暂存的内容</li><li><code>git stash drop</code> # 删除暂存区</li></ul><h3 id="六、Git-远程分支管理"><a href="#六、Git-远程分支管理" class="headerlink" title="六、Git 远程分支管理"></a>六、Git 远程分支管理</h3><ul><li><code>git pull</code> # 抓取远程仓库所有分支更新并合并到本地</li><li><code>git pull --no-ff</code> # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</li><li><code>git fetch origin</code> # 抓取远程仓库更新</li><li><code>git merge origin/master</code> # 将远程主分支合并到本地当前分支</li><li><code>git co --track origin/branch</code> # 跟踪某个远程分支创建相应的本地分支</li><li><code>git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;</code> # 基于远程分支创建本地分支，功能同上</li><li><code>git push</code> # push 所有分支</li><li><code>git push origin master</code> # 将本地主分支推到远程主分支</li><li><code>git push -u origin master</code> # 将本地主分支推到远程 (如无远程主分支则创建，用于初始化远程仓库)</li><li><code>git push origin &lt;local_branch&gt;</code> # 创建远程分支，origin 是远程仓库名</li><li><code>git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;</code> # 创建远程分支</li><li><code>git push origin :&lt;remote_branch&gt;</code> # 先删除本地分支 (<code>git br -d &lt;branch&gt;</code>)，然后再 push 删除远程分支</li></ul><h3 id="七、Git-远程仓库管理"><a href="#七、Git-远程仓库管理" class="headerlink" title="七、Git 远程仓库管理"></a>七、Git 远程仓库管理</h3><ul><li><code>git remote -v</code> # 查看远程服务器地址和仓库名称</li><li><code>git remote show origin</code> # 查看远程服务器仓库状态</li><li><code>git remote add origin git@github:robbin/robbin_site.git</code> # 添加远程仓库地址</li><li><code>git remote set-url origin git@github.com:robbin/robbin_site.git</code> # 设置远程仓库地址 (用于修改远程仓库地址)</li><li><code>git remote rm &lt;repository&gt;</code> # 删除远程仓库</li></ul><h3 id="八、创建远程仓库"><a href="#八、创建远程仓库" class="headerlink" title="八、创建远程仓库"></a>八、创建远程仓库</h3><ul><li><code>git clone --bare robbin_site robbin_site.git</code> # 用带版本的项目创建纯版本仓库</li><li><code>scp -r my_project.git git@git.csdn.net:~</code> # 将纯仓库上传到服务器上</li><li><code>mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init</code> # 在服务器创建纯仓库</li><li><code>git remote add origin git@github.com:robbin/robbin_site.git</code> # 设置远程仓库地址</li><li><code>git push -u origin master</code> # 客户端首次提交</li><li><code>git push -u origin develop</code> # 首次将本地 develop 分支提交到远程 develop 分支，并且 track</li><li><code>git remote set-head origin master</code> # 设置远程仓库的 HEAD 指向 master 分支</li></ul><h3 id="九、也可以命令设置跟踪远程库和本地库"><a href="#九、也可以命令设置跟踪远程库和本地库" class="headerlink" title="九、也可以命令设置跟踪远程库和本地库"></a>九、也可以命令设置跟踪远程库和本地库</h3><ul><li><code>git branch --set-upstream master origin/master</code></li><li><code>git branch --set-upstream develop origin/develop</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>导航</tag>
      
      <tag>分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界，您好！</title>
    <link href="/2025/05/01/hello-world/"/>
    <url>/2025/05/01/hello-world/</url>
    
    <content type="html"><![CDATA[<blockquote><p>五一劳动节 · 阳光灿烂的清晨<br>愿阳光洒满世界，愿和平常驻人间。</p></blockquote><span id="more"></span><p>今天是五一劳动节，阳光洒满大地，万物在光影中苏醒。微风轻拂面庞，仿佛是大自然温柔的问候。站在这个春意盎然的日子里，我想对这个世界郑重地说一声：</p><h2 id="“世界-您好！”"><a href="#“世界-您好！”" class="headerlink" title="“世界 您好！”"></a>“世界 您好！”</h2><p>生活是一首缓缓流淌的诗，每一个平凡的日子都蕴藏着无数细微的幸福。看见街头忙碌的人群，听见孩童清脆的笑声，感受阳光洒在身上的温度，我由衷地感谢这一切。<br>劳动让世界充满秩序与希望，而 <strong>和平</strong>，让这一切得以延续。</p><p>我热爱这宁静美好的时光，也珍惜那些被岁月温柔包裹的瞬间。在这个特别的节日里，我祈愿：</p><ul><li>✨ 愿世界远离纷争  </li><li>✨ 愿人们携手向善  </li><li>✨ 愿和平如阳光一般，照进每一个角落</li></ul><hr><p><strong>世界，您好！</strong><br>请继续包容我们这些渺小却热爱生命的灵魂，<br>让我们在温暖中前行，<br>在和平中生活，<br>在希望中成长。</p><p><strong>愿阳光洒满世界，愿和平常驻人间!</strong></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>劳动节</tag>
      
      <tag>生活</tag>
      
      <tag>和平</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
